尚德公司面试
1.java有什么特性，继承有什么用处，多态有什么用处
 答：java是面向对象的+简单的+分布式的+健壮+安全+可移植的+解释型的+高性能的+多线程的+动态的
     继承简化了人们对事物的认识的描述，能清晰体现相关类的层次结构关系，提供了软件复用功能，
     增强一致性减少模块间的接口的界面，大大增加程序的易维护性，提供多重继承机制。
     多态提高了代码的扩展性，前期定义的代码可使用后期的内容，弊端是前期定义的内容不能使用后期子类的特有内容。

2.反射是什么，在哪里用到，怎么利用反射创建一个对象
  答：先明确2个概念：
     静态编译：在编译时确定类型，绑定对象，即通过
	 动态编译：运行时确定类型，绑定对象，最大限度的发挥了java的灵活性，体现了多态的应用，有以降低类之间的耦合性。
	 java反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法
	 对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及调用对象方法的功能称为反射机制。
	 java程序可加载一个运行时才得知名称的classm,获悉其完整构造（不包括methods定义），并生成其对象实体、
     或对其fields设值，或唤起其methods。

3.代理模式与装饰模式的区别，手写一个静态代理，一个动态代理
   答：2者看起来都很像，都实现基础对象实现的接口，在其自身对象都保存着对被代理、被装饰者的对象引用。
  装饰者模式的定义：动态的将责任附加到被装饰者对象上，用于扩展对象的功能，比继承的灵活性大。java 的IO设计为典型应用
  代理模式定义：对其他对象进行代理，以控制对被代理对象的访问，spring 的业务逻辑层方法生成的代理类，主要进行一些事物控制
     由定义可以看出装饰的责任是扩展功能 ，而代理主要控制访问。

4.对象加载的过程，属性先加载还是方法先加载
   答：1.（静态变量和静态代码块）和（普通代码块和成员变量）看编写的顺序加载 如果静态代码块先加载然后打印静态变量会打印null.
       普通代码块同理。
   2.局部代码块和局部变量按编写顺序加载,构造代码块同理。
   3.子类和父类的方法只有调用才加载。

5.垃圾回收机制与jvm结构
       System.gc()用于调用垃圾收集器，在调用时，垃圾收集器将运行以回收未使用的内存空间，它将尝试释放被丢弃对象占用的内存，
   另此方法无法保证垃圾收集器的调用。所以 JVM怎么确定哪些对象应该进行回收呢？----
   引用计数法： 判断对象的引用数量，实现方式：给对象添加一个引用计数器，每当有引用对他进行引用时，计数器的值就+1，当引用失效，
 也就是不再执行此对象，它的计数器就-1，若某一个对象的计数器为0，那么表示这个对象没人对它引用，就会被gc回收掉。但不足！！！
    可达性计数法：因为上一个方法有缺陷才产生这个，通过判断对象的引用链是否可达来决定对象是否可以被回收。
	确定一哪些对象可被回收时，jvm在什么时机进行回收呢？
	1.会在cpu空闲时自动回收
	2.在堆内存存储满了后
	3，主动调用system.gc后尝试进行回收
	如何回收：-----
	1.标记-清除算法
	    标记所有需要回收的对象，标记完成后就进行统一回收掉哪些带有标记的对象，优点是简单，缺点是效率问题，标记清除后会产生
   大量不连续的
	内存碎片，当程序在以后的运行过程中，需要分配较大对象无法找到足够的连续内存而造成内存空间浪费。
	2.复制 算法：
	    复制将可用内存按容量划分成大小相同的2块，每次只使用其中的一块，当这块内存用完后，就将还存活的对象复制到另一块上，
		然后再把已使用的内存空间一次清理掉，这样 使得每次都是对其中的一块进行内存回收。内存分配时也就不用考虑内存碎片等
		情况了。只是这种算法的代价是将内存缩小为原来的一半。
    3.标记-整理算法
	    与标记清除算法相似，区别是仅对不存活的对象进行处理，剩余存活对象不做任何处理，造成内存碎片，而标记整理算法
		不仅对不存活对象进行清除，还对剩余存活的进行整理，重新整理，因此其不会产生内存碎片。
	4.分代收集算法
	    比较智能，是当下jvm使用最多的一种方法，他本身不是一个新的算法，而是他在具体的场景自动选择以上3种算法进行垃圾回收。
	jvm内存区----新生代      老年代    永久代
	    新生代的目标是尽可能的快速收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。
		   ----（如果老年代满了，就会触发一次FULL GC,也就是新生代，老年代都进行回收，注意，新生代发生的GC也叫做MinorGC,
		   minorGc发生频率高，不一定等eden区满了才触发）
	    老年代存放的都是一些生命周期长的对象，就像上面所叙述的那样，在新生代3经历了N次垃圾回收后仍然存活的对象就会放到此区。
		永久代主要用于存放静态文件，如java类，方法等。
		总结：
		1.在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可
	 完成收集。    2.老年代因为存活率高，没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。

6.自定义View,事件分发机制讲一讲
    事件序列
      1.手指接触屏幕后会产生一系列事件，action-down(手指刚接触屏幕)  action-move(手指在屏幕移动) action-up(手指从屏幕上松开)
	    事件传递的顺序：Activity---Window---decor view---我们的layout,viewGroup---我们布局中被点中的子view
	   如果子view没有消耗事件，那最后事件会传回Activity  由Activity处理（activity的onTouchevent调用）
     	三大方法  dispatchTouchEvent  onInterceptEvent onTouchEvent
	    dispatchTouchEvent 用来进行事件的分发，事件传递到当前的view时，此方法会被调用，此方法包含了具体的分发逻辑，返回结果受
        当前view的onTouchEvent方法和下级View的dispatchEvent方法影响。
        onIterceptTouchEvent方法在dispatchTouchEvent内部被调用，用来判断是否拦截某个事件，如果当前view拦截了某个事件，
        那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。此方法只有viewgroup中有，view没有
        onTouchEvent中用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗则在同一个事件序列中，当前view无法再次接收事件
        onTouchListener,onTouchEvent,onClicker的优先级
       1.onTouchListener和onTouchEvent都在dispatchOnTOuchEvent中被调用，onClicklistener在onTouchEvent中被调用。
       2.onTouchListener的优先级高于onTouchEvent方法，如果onTouchListener的onTouch方法返回true,则onTouchevent，
         onclicklistener不会调用，
       3.在onTouchEcvent方法中，如果当前view设置了onclicklistener那么onclicklistener的onclick会被调用
       4.只要view的clickable和long_clickable 有一个为true,view就会消耗当前事件，也就是说onTouchEvent方法会返回true
       5.view的long_clickable属性默认为false，而clickable的属性和具体的view有关
       viewgroup的事件分发逻辑
    public boolean dispatchEvent(MotionEvent event){
      boolean consume = false;
      if(onIterceptTouchEvent(event)){
        consume = onTouchEvent();
      }else{
        consume = child.dispatchTouchEvent(event)
      }
      return consume
    }
    从上伪代码中可总结出，
    ViewGroup中的事件分发流程：
    1.事件传递到viewgroup时，dispatchtouchevent会被调用 ，如果这个viewgroup的oniterceptTouchevent方法返回true,则表示它要
      拦截事件，事件就会交给当前viewgroup的onTouchEvent方法处理
    2,如果当前viewgroup的oniterceptTouchEvent返回false,即不拦截事件，则会调用子元素的dispatchTouchEvent，这样就传递给子元素
    3,如果子元素没消耗事件，也就是子元素的dispathchtouchEvent方法返回false，那事件会由当前viewgroup自己处理，当前viewgroup的
      onTouchEvent会被调用，如果当前viewgroup的dispatchEvent返回false,最后就会一层层往上，如果事件一直没消耗，那最后activity
      的 onTouchevent会被调用
    4.需要解释viewgroup继承自view，viewgroup并没有 onTouchevent方法，在所有子元素没消耗事件时，viewgroup会调用父类，也就是
       view的dispatchevent，从而调用onTouchEvent来自己处理事件，如果没消耗掉，dispatchevent会返回false,从而将事件向上层传递
    5.如果action-down事件子元素没处理（onTouchevent返回false） ,那此事件序列其他事件都不会分派给子元素处理
    6.viewgroup默认不拦截任何事件
    7.对于action-down事件，viewgroup每次都会调用onitercepttouchevent方法来判断是否需要拦截事件，一旦确认要拦截，后续的
      action-move和action-up都viewgroup自己处理，不会传递给子view。也不会调用onitercepttouchevent，所以onitercepttouchevent
      方法不是每次事件都会被调用的。
    8.子view可通过requestDisallowInterceptTouchEvent来干预父元素的除了action-down的事件分发过程
      View的事件分发逻辑    -----requestDisallowInterceptTouchEvent
      requestDisallowInterceptTouchEvent方法用于影响父元的事件拦截策略
      requestDisallowInterceptTouchEvent（true）表示不允许父元素拦截事件，这样事件就传递给子view，----大都用于处理滑动冲突
     常用的滑动冲突处理逻辑
        1.利用父布局的onitercepttouchevent.思路是在父布局需要处理事件拦截下来，其他时候不拦截
        对于action-down事件，onitercepttouchevent方法必须返回true,因为一旦返回true,子元素永远也接收不到事件了，还解决毛线
        主要的逻辑在action-move上，是否需要拦截在这写
        对于acTion-up返回false，因为一旦父元素返回true,那view就接收不到action-up事件，也无法触发onclick事件
       2.利用子view的requestDisallowInterceptTouchEvent
       父布局默认拦截除了action-down的所有事件，子view中在dispatchtouchevent方法根据需要来干预父布局的拦截策略，默认不允许
       父布局拦截事件，在需要父布局处理事件时，通过requestDisallowInterceptTouchEvent（false）让父布局处理事件,其他子view处理
       注意：同样的对于action-down事件，onitercepttouchevent必须返回false,其他默认返回true,
         在子view的didpatchtouchevent中，对于action-down通过调用requestDisallowInterceptTouchEvent（true）默认不允许
      父布局拦截事件，这样后续事件交给子view处理
         在子view的dispatchtouchevent，对于action-move事件，默认是子view处理，在需要父布局处理时，调用
      requestDisallowInterceptTouchEvent（false）方法让父布局拦截事件，交给父布局处理。

7.http与https有什么区别
   1.传输信息安全性不同
     http协议：超文本传输协议，信息明文传输，如果攻击者截取web浏览器的网站服务器之间的传输报文，就可直接读懂其信息
     https协议：具有安全性的SSL加密传输协议，为浏览器和服务器的通信加密，确保数据传输安全
   2.连接方式不同
     http:无状态的   https:SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议
   3.端口不同   http  80   https  443

9.静态方法，静态对象为什么不能继承
   java中静态属性和静态方法可以被继承，但没有被重写（overwrite）而是被隐藏
   原因：
   1.静态方法和属性是属于类的，调用的蚨直接通过类名，不需要继承机制也可调用
   2.多态之所以能够实现依赖继承+接口和重写+重载（继承和重写最关键）。有了继承和重写就可实现父类的引用指向子类的对象。
     重写和功能：重写后子类的优先级高于父类的优先级，但隐藏没优先级之分
   3.静态属性：静态方法和非静态的属性都可以继承和隐藏而不能被重写。因此不能实现多态，不能实现父类的引用指向不同子类的对象
      非静态方法可被继承和重写，因此可实现多态。

10.Activity怎么启动Service，Activity与Service交互，Service与Thread的区别

   2种启动方式的不同。如果在Service的onCrete或onStart做了耗时，会影响UI操作或阻塞主线程，最好在Service启动一个线程

   staerService会经历oncreate--onStart(如果Service还没运行，则andRoid先调用oncreate再调用onstart,如service已运行，
   则只调用onstart,所以Service的ondstart可能会多次调用)，stopService直接ondestory,如果调用都自己直接退出而没有调用、
   stopservice，serview会一直在后台运行，

   bindService会经历oncreate--onbind传递给unbindservice的intent对象会传递到onUnbind方法，注意：在service每一次
   开启关闭过程中，只的onstart可被多次调用，其他方法在一个生命周期中只会调用一次

11.介绍一下android动画
   帧动画  补间动画   属性动画

12.Launcher启动App的流程，中间有几种跨进程通信(socket)

13.Handler通信，Binder通信

15.RXJava怎么切换线程



16.Fragment hide show生命周期
   19.Fragment replace生命周期变化     --- https://blog.csdn.net/pxcz110112/article/details/81095738
                                      --- https://blog.csdn.net/tiantaiaiqing/article/details/79527350
   
   当使用hide、show方法来控制Fragment使用时，Fragment生命周期将不执行，在onResume以及onPause方法处理的事情
   将由onHiddenChange进行管理，当Fragment调用hide隐藏时，

   该方法会被调用，传入参数为true，表示该Fragment被隐藏了，当Fragment调用了show方法后，该方法传入的参数为
   false，表示该Fragment正在显示。
   
     总结：1、replace，加回退栈，Fragment不销毁，但是切换回销毁视图和重新创建视图。

          2、replace,不加回退栈，Fragment销毁掉。

          3、hide、show,Fragment不销毁，也不销毁视图。隐藏和显示不走生命周期。

17.平常有用到什么锁，synchronized底层原理是什么

 synchronized的特性   原子性+ 可见性+ 有序性+ 可重入性

    原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，
 要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成读取、计算、赋值几步操作，原值在这些步骤
 还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。
 被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完
 才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。

    可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。
synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象
必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，
保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。
而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，
所以确保了其他线程读取到的变量永远是最新值，保证可见性。

    有序性值程序执行的顺序按照代码先后执行。
synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，
它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行
同步代码块是分先后顺序的，保证了有序性。

    synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会
处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了
锁仍然还可以重复申请锁

Vivo公司
1.简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障
   从代码层面上来讲，同步屏障就是一个Message，一个target字段为空的Message。
 同步屏障的工作原理:
   同步屏障只在Looper死循环获取待处理消息时才会起作用，也就是说同步屏障在MessageQueue.next函数中发挥着作用。
   当设置了同步屏障之后，next函数将会忽略所有的同步消息，返回异步消息。换句话说就是，设置了同步屏障之后，
   Handler只会处理异步消息。再换句话说，同步屏障为Handler消息机制增加了一种简单的优先级机制，异步消息的优先级要高于同步消息
 同步屏障的应用
 Android应用框架中为了更快的响应UI刷新事件在ViewRootImpl.scheduleTraversals中使用了同步屏障
 void scheduleTraversals() {
     if (!mTraversalScheduled) {
         mTraversalScheduled = true;
         //设置同步障碍，确保mTraversalRunnable优先被执行
         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
         //内部通过Handler发送了一个异步消息
         mChoreographer.postCallback(
                 Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
         if (!mUnbufferedInputDispatch) {
             scheduleConsumeBatchedInput();
         }
         notifyRendererOfFramePending();
         pokeDrawLockIfNeeded();
     }
 }
 mTraversalRunnable调用了performTraversals执行measure、layout、draw
 为了让mTraversalRunnable尽快被执行，在发消息之前调用MessageQueue.postSyncBarrier设置了同步屏障


2.Glide的缓存，有用过Glide的什么深入的API，自定义model是在Glide的什么阶段  ------>----重写glidemodel,重写applyOption
   1.with()
     with提供了几种构造方法，可以在源码里看，有Context, Activity, Fragment等，如果传入Application.this
    作为参数时，Glide的加载不受当前Activity生命周期影响，但这会导致即使Activity结束后，仍然继续加载图片。
   2.load()
   load可以加载网络图片链接，也可以加载本地图片地址，以及resourceId, File等等
   3.into()
   into直接传入ImageView;
   4.placeholder()
   在加载过程中设置占位图，可以传入Drawable或resouceId
   5.error()
   加载失败显示的图片，可以传入Drawable或resouceId
   6.override(int width, int height)
   设置加载图片的宽高，像素为单位，在自定义ImageView大小或者计算瀑布流高度时，偶尔会用到。
   7.dontAnimate()
   Glide加载时默认会有淡入淡出的加载效果，该方法可以去掉动画效果，直接显示图片
   8..skipMemoryCache(true)
   跳过图片缓存
   9.diskCacheStrategy(DiskCacheStrategy.ALL)
   设置缓存策略，可选的参数有 ：ALL(缓存所有数据), NONE(不缓存), SOURCE(只缓存源数据), RESULT(只缓存转换后的数据);
   10.priority(Priority.NORMAL)
   加载优先级，优先级越高越先加载
   11.crossFade(int duration)
   加载时淡入淡出动画时间，也可以不传，默认300ms
   12.animate()
   自定义加载动画
   13.thumbnail(0.1f)
   设置缩略图，先加载缩略图再加载完整图片,在大量的图片流列表里,这个方法还是挺好用的, 快速滑动列表时,不致于出现大量的空白.
   14.asBitmap()
   把图片当成bitmap对待，如果是Gif时会停留在第一帧
   15.asGif()
   加载GIF图片，不加该方法时，也可以加载GIF；加了该方法，如果资源不是GIF，会加载失败。
   16.bitmapTransform()
   对图片进行转换，只能用于bitmap
   17.transform()
   对图片进行转换
   16.Glide.get(this).clearDiskCache()
   清理磁盘缓存，需要在子线程中执行
   17.Glide.get(this).clearMemory();
   清理内存缓存，可以直接在主线程执行


3.讲讲mvc,mvp模式，presenter内存泄漏的问题

   p层的耗时任务在页面销毁时是否执行很关键：假设当页面销毁时，presenter层内的任务执行完，由于presenter没有再被内部
   类等持有引用，所以presenter是会被回收的，那view层也不被presenter持有引用，所以即使没在View销毁时清空软引用和置
   View为null，View同样会被销毁，不存在内存泄漏问题

   V层是否被presenter弱引用持有决定V层是否会内存泄漏：假设当页面销毁时，presenter层内的任务在执行, 由于V是被
   presenter弱引用持有，所以V是会被GC回收的，而Presenter由于任务还在执行，所以回收不了

   页面销毁时结束耗时任务可解决presenter和View的内存泄漏， 假设当页面销毁时，即使presenter对View是强引用持有，
   只要此时任务执行完或者解绑Rx的订阅，presenter和View都是可以被回收的，所以不存在内存泄漏

   Rx上游创建异步耗时线程跑，即使取消订阅，还是会内存泄漏，可能Rx不知道开了一个子线程在跑,而子线程持有presenter的引用

   线程的调度放心交给Rx来处理：Rx上游创建异步耗时线程跑，即使取消订阅，还是会内存泄漏，可能Rx不知道开了一个子线程在跑,
   而子线程持有presenter的引用 (这里参考链接 在Rx的上游执行异步耗时任务的测试)

   所以发生泄漏主要在: presenter的引用被rx开辟的线程所持有(或者Model的引用被持有), 从而导致V的引用被持有

   线程运行中，而View界面已经关闭，由于presenter不能被回收(被内部类持有引用)，所以导致presenter内存泄漏

   而如果View是被Presenter强引用持有的话，那View也不能被回收

   而如果View是被presenter弱引用持有的话，那么View是可以被GC回收的

   View的界面销毁, 此时线程运行结束或解除rx的订阅，由于presenter已不再被持有引用，故可GC回收, 而不管View是被
   Presenter强引用还是弱引用，View都会被GC回收

   MVP的内存泄漏可以通过解除Rx的订阅(RxLifecycle2框架或AutoDispose框架)来解决，前提是耗时任务都在Rx里去操作,
   使得Model、View、Presenter不被持有引用，从而可回收


4.ANR了解过吗？有没有实际的ANR定位问题的经历

     1. ANR错误定义：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称
   作“应用程序无响应”（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以
   选择“强制关闭”。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。
   默认情况下，在Android中Activity的最长执行时间是5秒（主要类型），BroadcastReceiver的最长执行时间的则是
   10秒，ServiceTimeout的最长执行时间是20秒（少数类型）。超出就会提示应用程序无响应（ANR错误）。

      2.ANR错误出现原因：只有当应用程序的UI线程响应超时才会引起ANR 超时产生的原因包括：①当前事件没有机会处理，
   例如UI线程正在响应另外的事件，当前事件被某个事件给阻塞掉了；②当前事件正在处理 但是由于耗时太长没有能及时的
   完成。其他原因：③在BroadcastReceiver里做耗时的操作或计算；④CPU使用过高；⑤发生了死锁；⑥耗时操作的动画需要
   大量的计算工作，可能导致CPU负载过重。
     ANR定位方式及优化
   1.如果开发机器上出现ANR问题时，系统会生成一个traces.txt的文件放在/data/anr下，最新的ANR信息在最开始部分。
     通过adb命令将其导出到本地，输入以下字符： $adb pull data/anr/traces.txt
   2.为了执行一个长时间的耗时操作而创建一个工作线程最方便高效的方式是使用AsyncTask，只需要继承AsyncTask
     并实现doInBackground()方法来执行任务即可。为了把任务执行的进度呈现给用户，你可以执行publishProgress()方法，
     这个方法会触发onProgressUpdate()的回调方法。在onProgressUpdate()的回调方法中(它执行在UI线程)，你可以执行
     通知用户进度的操作
   3.如果你实现了Thread或者HandlerThread，请确保你的UI线程不会因为等待工作线程的某个任务而去执行Thread.wait()
     或者Thread.sleep()。UI线程不应该去等待工作线程完成某个任务，你的UI线程应该提供一个Handler给其他工作线程，
     这样工作线程能够通过这个Handler在任务结束的时候通知UI线程。
   4.开发在日常的开发过程中使用Thread或者HandlerThread，可以尝试调用
     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置较低的优先级，否则仍然会降低程序响应，
     因为默认Thread的优先级和主线程相同。
   5.Activity的onCreate和onResume回调中尽量避免耗时的代码，应该尽可能的做比较少的事情，其实，任何执行在UI线程
     中的方法都应该尽可能简短快速。类似网络或者DB操作等可能长时间执行的操作，或者是类似调整bitmap大小等需要
     长时间计算的操作，都应该执行在工作线程中
   6.BroadcastReceiver中onReceive代码也要尽量减少耗时。如果必须在onReceive方法中执行耗时操作，建议使用
     IntentService进行处理，IntentService集开启线程和自动关闭服务两种功能于一身
   7.增加界面响应性（交互层面），这是一个成熟应用必备的标志—通常来说，100ms - 200ms是用户能够察觉到卡顿的上限。
     如果你的程序在启动阶段有一个耗时的初始化操作，可以考虑显示一个闪屏，要么尽快的显示主界面，然后马上显示一个
     加载的对话框，异步加载数据。无论哪种情况，你都应该显示一个进度信息，以免用户感觉程序有卡顿的情况

   辅助处理ANR问题的工具：
       Traceview - 系统性能分析工具，用于定位应用代码中的耗时操作


5.性能优化你做过哪些？
   1. 我发现程序在冷启动的时候，会有 1s 左右的白屏闪现，低版本是黑屏的现象，在这期间我通过翻阅系统主题源码，发现
     系统 AppTheme 设置了一个 windowBackground ，由此推断就是这个属性捣的鬼，开始我是通过设置
      windowIsTranslucent 透明属性，发现虽然没有了白屏，但是中间还是有一小段不可见，这个用户体验还是不好的。
     最后我观察了市面上大部分的 Android 软件在冷启动的时候都会有一个  Splash 的广告页，同时在增加一个倒数的计时
     器，最后才进入到登录页面或者主页面。我最后也是这样做的，原因是这样做的好处可以让用户先基于广告对本 APP
     有一个基本认识，而且在倒数的时候也预留给咱们一些对插件和一些必须或者耗时的初始化做一些准备。
   2. 通过翻阅 Application 启动的源码，当我们点击桌面图标进入我们软件应用的时候，会由 AMS 通过 Socket 给
     Zygote 发送一个 fork 子进程的消息，当 Zygote fork 子进程完成之后会通过反射启动 ActivityThread##main
     函数，最后又由 AMS 通过 aidl 告诉 ActivityThread##H 来反射启动创建Application 实例，并且依次执行
     attachBaseContext 、onCreate 生命周期，由此可见我们不能在这 2 个生命周期里做主线程耗时操作。
   3.知道了  attachBaseContext 、onCreate  在应用中最先启动
     项目不及时需要的代码通过异步加载。
     将对一些使用率不高的初始化，做懒加载。
     将对一些耗时任务通过开启一个 IntentService来处理。
   4.Application 启动完之后，AMS 会找出前台栈顶待启动的 Activity , 最后也是通过 AIDL 通知 ActivityThread#H
     来进行对 Activity 的实例化并依次执行生命周期 onCreate、onStart、onRemuse  函数，那么这里由于 onCreate
     生命周期中如果调用了 setContentView 函数，底层就会通过将 XML2View 那么这个过程肯定是耗时的。
     所以要精简 XML 布局代码，尽可能的使用 ViewStub、include 、merge 标签来优化布局。接着在 onResume 声明
     周期中会请求 JNI 接收 Vsync (垂直同步刷新的信号) 请求，16ms 之后如果接收到了刷新的消息，那么就会对
     DecorView 进行 onMeasure->onLayout->onDraw 绘制。最后才是将 Activity 的根布局 DecorView 添加到
     Window 并交于 SurfaceFlinger 显示。
     所以这一步除了要精简 XML 布局，还有对自定义 View 的测量，布局，绘制等函数不能有耗时和导致 GC 的操作。
     最后也可以通过 TreaceView 工具来检测这三个声明周期耗时时间，从而进一步优化，达到极限。
     好处：
        1.  减少 OOM ，可以提高程序的稳定性。---- LeakCanary 这款性能检测工具
        2. 减少卡顿，提高应用流畅性。
            绘制原理：
            Activity--->
              1.onCreate  当activity成功创建，并调用oncreate生命周期时，会执行setcontentview布局id转换
                为view对象的一个过程。
              2.onResume  拿到转换后的view tree 请求vsync垂直同步的信息，收到消息后会执行
                performtraversals函数实现绘制
                包含以下3个方法
                onMeasure  用深度优先的原则递归所有视图的宽高，获取当前view的正确宽高后,可调用它的成员函数
                measure来设置它的大小，如果当前正在测量的子视图child是一个容器，那它又会重复执行操作，直到
                它的所有子视图的大小都测量完毕。
                onLayout  用深度优先原则得到所有视图view的位置，当一个子view在应用程序窗口左上角的位置确定
                后，再结合它在前面测量过中确定的宽高，就可完全确定它在应用程序窗口中的布局。
                onDraw    目前安卓支持2种绘制方式：软件绘制和硬件加速（android3.0已全面支持），硬件加速在
                UI 的显示和绘制的效率远高于CPU的绘制，缺点：1.耗电问题，cpu的功耗比cpu高   2.兼容问题，
                某些接口和函数不支持硬件加速  3，内存大：使用opengl的接口至少需要8MB的内存
            刷新原理:
            View 的 requestLayout 和 ViewRootImpl##setView 最终都会调用 ViewRootImpl 的 requestLayout
            方法，然后通过 scheduleTraversals 方法向 Choreographer 提交一个绘制任务，然后再通过
            DisplayEventReceiver 向底层请求 vsync 垂直同步信号，当 vsync 信号来的时候，会通过 JNI
            回调回来，在通过 Handler 往消息队列 post 一个异步任务，最终是 ViewRootImpl 去执行绘制任务，
            最后调用 performTraversals 方法，完成绘制。
            卡顿的根本原因：1.一个是主线程有其它耗时操作，导致doFrame没机会在vsync信号发出16毫秒内调用
                           2.当前doFrame方法耗时，绘制太久，下一个vsync信号来的时候这一帧还没画完，掉帧
             
        3. 减少内存占用，提高应用后台存活性。
        4. 减少程序异常，降低应用 Crash 率, 提高稳定性。


6.有什么实际解决UI卡顿优化的经历
   答：常见卡顿原因及解决方案：
     
     一、过度绘制
     
     去除不必要的背景色：
     
     (1) 设置窗口背景色为通用背景色，去除根布局背景色
     
     (2) 若页面背景色与通用背景色不一致，在页面渲染完成后移除窗口背景色
     
     (3) 去除和列表背景色相同的Item背景色
     
     布局视图树扁平化：
     
     (1) 移除嵌套布局
     
     (2) 使用merge、include标签
     
     (3) 使用性能消耗更小布局（ConstraintLayout）
     
     减少透明色，即alpha属性的使用：
     
     (1) 通过使用半透明颜色值(#77000000)代替
     
     二、UI 线程的复杂运算
     
     UI线程的复杂运算会造成UI无响应, 当然更多的是造成UI响应停滞, 卡顿。产生ANR已经是卡顿的极致了
     
     解决方案：运算阻塞导致的卡顿的分析, 可以使用 Traceview 这个工具。
     
     三、频繁的 GC
     
     频繁GC的原因：(1) 内存抖动(Memory Churn), 即大量的对象被创建又在短时间内马上被释放。(2) 瞬间产生大量的对象会严重占用 Young Generation 的内存区域, 当达到阀值, 剩余空间不够的时候, 也会触发 GC。即使每次分配的对象需要占用很少的内存，但是叠加在一起会增加 Heap 的压力, 从而触发更多的 GC。
     
     解决方案：瞬间大量产生对象一般是因为我们在代码的循环中 new 对象, 或是在 onDraw 中创建对象等， 尽量不要在循环中大量的使用局部变量。
     
     
     过度绘制检测
     
     在Android手机的"系统设置"-->"开发者选项"-->"调试GPU过度绘制"-->"显示GPU过度绘制"中开启调试。
     
     蓝色，淡绿，淡红，深红代表了4种不同程度的过度绘制(Overdraw)情况。

7.有做过什么Bitmap优化的实际经验

8.项目搭建过程中有什么经验,有用到什么gradle脚本，分包有做什么操作

9.组件化有详细了解过吗？ARouter详细原理


10.讲一下事件分发机制,RecyclerView是怎么处理内部ViewClick冲突的
     https://blog.csdn.net/yzpbright/article/details/108540286
     
     
11.mainfest中配置LargeHeap，真的能分配到大内存吗？
    答：  android:largeHeap="true"虽然会申请更大的内存解决OOM，但是带来的后果是 系统gc垃圾回收时间也会变长，如果在application中配置的话会使应用性能降低，比如recyclerview 滑动会变得异常卡顿。如果要解决OMM建议不要在application中配置，最好另寻他法。
    
B站
1.一个大致有序的数组如何排序，最快时间复杂度
     #define SIZE 65535
     void Sort(int* a, int len)
     {
         int *data=new int[SIZE];
         memset(data, 0, sizeof(int)*SIZE);//这里必须先将开辟的数组空间初始化为0
         if (a == NULL)
         {
             return;
         }
         int i = 0;
         for (i = 0; i < len; i++)
         {
             data[a[i]]++;
         }
         int j = 0;
     
         for (i = 0; i < SIZE; i++)
         {
             if (data[i] != 0)
             {
                 while (data[i]--)//出现相同数
                 {
                     a[j++] = i;
                 }
             }
         }
         delete[]data;//记得释放空间
     }
     
     
2.如果叫你实现，你会怎样实现一个多主题的效果
      创建ColorTheme类用于主题更换：
      
      public class ColorTheme {
        AppCompatActivity ap;
        public ColorTheme(AppCompatActivity _ap){ap=_ap;}
        public void updateTheme(int _data){
          String data=Integer.toString(_data);
          FileOutputStream out=null;
          BufferedWriter writer=null;
          try{
            out=ap.openFileOutput("data",Context.MODE_PRIVATE);
            writer=new BufferedWriter(new OutputStreamWriter(out));
            writer.write(data);
          }catch (IOException e){
            e.printStackTrace();
          }finally {
            try {
              if(writer!=null){
                writer.close();
              }
            }catch (IOException e){
              e.printStackTrace();
            }
          }
        }
        public void loadTheme(){
          FileInputStream in=null;
          BufferedReader reader= null;
          StringBuilder content=new StringBuilder();
          try{
            in=ap.openFileInput("data");
            reader=new BufferedReader(new InputStreamReader(in));
            String line="";
            while((line=reader.readLine())!=null){
              content.append(line);
            }
            ap.setTheme(Integer.parseInt(content.toString()));
          }catch (IOException e){
            e.printStackTrace();
          }finally {
            if(reader!=null){
              try{
                reader.close();
              }catch (IOException e){
                e.printStackTrace();
              }
            }
          }
        }
      }
      在oncreate中调用：
      
      protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final ColorTheme newTheme = new ColorTheme(this);
        newTheme.loadTheme();
        setContentView(R.layout.activity_main);
      重点：
      
      要现在res/value/style中设计主题的样式：
      
      这里是我设的的四种样式：
      
      
      <?xml version="1.0"?>
        <resources>
        <!-- Base application theme. -->
        -<style parent="Theme.AppCompat.Light.NoActionBar" name="AppTheme">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
        <item name="colorButtonNormal">@color/colorAccent</item>
      </style>
        -<style parent="Theme.AppCompat.Light.NoActionBar" name="Blue">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/blue</item>
        <item name="colorPrimaryDark">@color/blue</item>
        <item name="colorAccent">@color/blue</item>
        <item name="colorButtonNormal">@color/blue</item>
      </style>
        -<style parent="Theme.AppCompat.Light.NoActionBar" name="Pink">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/pink</item>
        <item name="colorPrimaryDark">@color/pink</item>
        <item name="colorAccent">@color/pink</item>
        <item name="colorButtonNormal">@color/pink</item>
      </style>
        -<style parent="Theme.AppCompat.Light.NoActionBar" name="Turquoise">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/turquoise</item>
        <item name="colorPrimaryDark">@color/turquoise</item>
        <item name="colorAccent">@color/turquoise</item>
        <item name="colorButtonNormal">@color/turquoise</item>
      </style>
      </resources>
      别忘了在color里定义的颜色：
      
      
      <?xml version="1.0" encoding="UTF-8"?>
        <resources>
        <color name="colorText">#ffffffff</color>
        <color name="hintText">#bfffffff</color>
        <color name="colorPrimary">#de4037</color>
        <color name="colorPrimaryDark">#de4037</color>
        <color name="colorAccent">#de4037</color>
        <!--注册界面提示红色-->
        <color name="hintRed">#de4037</color>
        <color name="blue">#1e50a2</color>
        <color name="pink">#fa7299</color>
        <color name="turquoise">#008577</color>
      </resources>
 
3.如何自定义实现一个FlexLayout
    首先新建一个FlowLayout类，继承自ViewGroup
    在onMeasure中根据 child views 计算出FlowLayout高度
    在onLayout中对child views 的进行布局（layout）
    
    在onMeasure中计算FlowLayout的高度
    // 遍历所有的子View
    for (int i = 0, childCount = getChildCount(); i < childCount; ++i) {
        View childView = getChildAt(i);
        // measure子View，并获取它的宽度和高度
        LayoutParams childLayoutParams = childView.getLayoutParams();
        childView.measure(
                getChildMeasureSpec(widthMeasureSpec, paddingLeft + paddingRight, childLayoutParams.width),
                getChildMeasureSpec(heightMeasureSpec, paddingTop + paddingBottom, childLayoutParams.height));
        int childWidth = childView.getMeasuredWidth();
        int childHeight = childView.getMeasuredHeight();
        // 计算当前行的高度（当前行所有子View中最高的那个）
        lineHeight = Math.max(childHeight, lineHeight);
    
        // 把当前child view放到上一个child view的右边，如果放不下，则换行
        if (childLeft + childWidth + paddingRight > myWidth) {
            childLeft = paddingLeft;
            childTop += mVerticalSpacing + lineHeight;
            lineHeight = childHeight;
        } else {
            childLeft += childWidth + mHorizontalSpacing;
        }
    }
    
    int wantedHeight = childTop + lineHeight + paddingBottom;
    // 计算FlowLayout所需要高度
    setMeasuredDimension(myWidth, resolveSize(wantedHeight, heightMeasureSpec));
    
    在onLayout中对child views进行布局
    代码与onMeasure非常类似，只需要根据child view的宽度和高度放到指定位置即可。
    
    for (int i = 0, childCount = getChildCount(); i < childCount; ++i) {
        View childView = getChildAt(i);
    
        if (childView.getVisibility() == View.GONE) {
            continue;
        }
    
        int childWidth = childView.getMeasuredWidth();
        int childHeight = childView.getMeasuredHeight();
    
        lineHeight = Math.max(childHeight, lineHeight);
    
        if (childLeft + childWidth + paddingRight > myWidth) {
            childLeft = paddingLeft;
            childTop += mVerticalSpacing + lineHeight;
            lineHeight = childHeight;
        }
        
        // 关键代码
        childView.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
        childLeft += childWidth + mHorizontalSpacing;
    }

4.tinker的原理是什么,还用过什么热修复框架，robust的原理是什么？


5.说说你对注解的了解，是怎么解析的


6.synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的
     公平锁：
     获取不到锁的时候，会自动加入队列，等待线程释放后，队列的第一个线程获取锁
     非公平锁:
     获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争
     什么是可重入？
     同一个线程可以反复获取锁多次，然后需要释放多次
                       回答标题问题：synchronized 是非公平锁，可以重入。
     在来看几个问题：
     1、 synchronized 加在 static 修饰的 方法上锁的是哪个对象？
     答：锁的是 Class 对象
     2、synchronized(this)  锁的是哪个对象？
     答：锁的是当前对象的实例也就是 new 出来的对象
     3、synchronized() 锁的是哪个对象？
     答：同  synchronized(this) 锁的也是当前对象的实例
     4、synchronized(lock) 锁的是哪个对象？
     答：锁的是 lock 对象。
     5、同一个对象里面 有 static 方法加了 synchronized 还有一个普通方法也加了  synchronized 如果这个时候有2个线程，一个先获取 了 static 方法上的锁，另外一个线程可以在 第一个线程释放锁之前获取 普通方法上的锁吗？反过来呢？
     答：可以的，因为这是 2 把锁，2 个线程分别获取2把锁，没有任何问题。


7.泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的
      
10.在项目中有直接使用tcp,socket来发送消息吗

12.生命周期都是通过什么调用的？有用过AIDL吗？

8.mvp与mvvm的区别，mvvm怎么更新UI,databinding用得多吗,databinding的原理？
     mvp与mvvm的区别：mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding): View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作，框架已经帮你做好了

9.kotlin ?的原理 
      kotlin的编译过程基本就是，插件 - kotlin任务 - 编译器 - 生成方法、属性 - 利用ASM生成字节码
      

11.如何在网络框架里直接避免内存泄漏，不需要在presenter中释放订阅
      在 Activity 执行 onDestroy() 方法之前，调用 Presenter 自定义一个 onDestroy() 方法，因为 Presenter 持有 Activity View 的应用，所以在 Presenter 的 onDestroy() 方法里面把 View = null，在 Presenter 执行 网络请求或者其他的耗时操作，结果返回都必须执行 if（view != null ）操作判断。

13.讲一下RecyclerView的缓存机制,滑动10个，再滑回去，会有几个执行onBindView
     滑动10个，再滑回去，bindview可以是19次调用，可以是16次调用。    https://www.cnblogs.com/jimuzz/p/14040674.html

14.如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数？   https://www.cnblogs.com/jimuzz/p/14040674.html
     关于view的局部刷新就是notifyItemChanged(int, Object)方法，下面具体说说：
     notifyItemChange有两个构造方法：
     notifyItemChanged(int position, @Nullable Object payload)
     notifyItemChanged(int position)
     其中payload参数可以认为是你要刷新的一个标示，比如我有时候只想刷新itemView中的textview,有时候只想刷新imageview？又或者我只想某一个view的文字颜色进行高亮设置？那么我就可以通过payload参数来标示这个特殊的需求了。


15.讲讲LinkedHashMap的数据结构    -------    https://blog.csdn.net/weixin_42226343/article/details/103812045

17.A Activity打开B Activity的生命周期变化，会有什么方法打断吗？    ------https://blog.csdn.net/weixin_43589682/article/details/97030740

6.h5与native通信你做过什么工作？    ----https://www.jianshu.com/p/bcb5d8582d92       https://blog.csdn.net/u012532559/article/details/78301430

16.put post有什么区别
    POST 方法用来传输实体的主体
    PUT方法用来传输文件
    它们最根本的区别就是：POST方法不是幂等的，而PUT方法则有幂等性
    幂等：一个幂等操作的特点就是其任意多次执行所产生的影响均与依次一次执行的影响相同。
    POST在请求的时候，服务器会每次都创建一个文件，但是在PUT方法的时候只是简单地更新，而不是去重新创建。
    
B站二面    9.如果产品要求你开发一个音频播放功能，你会怎么着手？预计会有什么坑？


7.插件化的主要优点和缺点是什么？
    优点：让用户不用重新安装 APK 就能升级应用功能，减少发版本频率，增加用户体验。
         提供一种快速修复线上 BUG 和更新的能力。
         按需加载不同的模块，实现灵活的功能配置，减少服务器对旧版本接口兼容压力。
         模块化、解耦合、并行开发、 65535 问题。
    缺点：1）开发插件需要时间，可能拖延项目工期，如果工期紧急不建议选用这种方式
        （2）自己造的轮子未必有现有轮子的好用，要考虑到队友是否适用
        （3）需要比较高的开发水平

10.ViewPager切换Fragment什么最耗时？
     答：当ViewPager切换到当前的Fragment时，Fragment会加载布局并显示内容，如果用户这时快速切换ViewPager，即Fragment需要加载UI内容，而又频繁地切换Fragment，就容易产生卡顿现象（类似在ListView快速滑动的同时加载图片容易卡顿）。
       
       优化方案：
       
       1.Fragment轻量化
       
       如果ViewPager加载的Fragment都比较轻量，适当精简Fragment的布局，可提高Fragment加载的速度，从而减缓卡顿现象。
       
       2.防止Fragment被销毁
       
       ViewPager在切换的时候，如果频繁销毁和加载Fragment，就容易产生卡顿现象，阻止Fragment的销毁可有效减缓卡顿现象。
       
       (1)在PagerAdapter里覆盖destroyItem方法可阻止销毁Fragment

       @Override   
       public void destroyItem(ViewGroup container, int position, Object object) {      
       　　　　//super.destroyItem(container, position, object);    
       }
       (2)通过PagerAdapter的setOffscreenPageLimit()方法可以设置保留几个Fragment，适当增大参数可防止Fragment频繁地被销毁和创建。
       
       风险：在Fragment比较多的情况下，部分低端机型容易产生OOM问题。
       
       3.Fragment内容延迟加载
       
       (1) 描述
       
       在切换到当前Fragment的时候，并不立刻去加载Fragment的内容，而是先加载一个简单的空布局，然后启动一个延时任务，延时时长为T，当用户在该Fragment停留时间超过T时，继续执行加载任务；而当用户切换到其他Fragment，停留时间低于T，则取消该延时任务。
       
       (2) 具体操作
       
       首先，设置延迟任务

       private Runnable LOAD_DATA = new Runnable() {    
           @Override   
           public void run() {      
            //在这里数据内容加载到Fragment上    
           }  
       };
       启动任务
       
       @Override
       public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { 
         //初始化视图，这里最好先设置一个进度对话框，提示用户正在加载数据
         initView();
         //启动任务，这里设置500毫秒后开始加载数据  handler.postDelayed(LOAD_DATA,500)
         return view；
       }
       若用户切换到其他Fragment则取消任务
       
       //判断Fragment是否可视的重载方法
       @Override 
       public void setUserVisibleHint(boolean isVisibleToUser) {    
       　　super.setUserVisibleHint(isVisibleToUser);    
       　　　　if(!isVisibleToUser)        
       　　　　  mHandler.removeCallbacks(LOAD_DATA);
       }
       (3) 注意
       
       使用setUserVisibleHint判断用户是否切换到其他Fragment，这样的做法有个缺陷，因为会在ViewPager开始滑动的时候取消延时任务，而在滑动偏移量不足的情况下，ViewPager会继续回滚到当前Fragment，导致当前Fragment的加载任务被取消而又不会重新启动加载任务。
       
       这里我使用的做法是，给ViewPager增加一个OnPageChangeListener,，该监听器的onPageSelected(position)能监听ViewPager当前切换到哪个Fragment，在这里将其他Fragment的延迟加载任务取消掉。



11.线程间同步的方法

    1.同步方法 
    
    即由synchronized关键字修饰的方法。
    
    由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
    
    代码如：
    
    public synchronized void save(){
    
    ……
    
    }
    
    注：synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
    
    2.同步代码块 
    
    即由synchronized关键字修饰的语句块。
    
    被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
    
    代码如：
    
    synchronized(object){
    
    }
    
    注：同步是一种高开销的操作，因此应该尽量减少同步的内容。
    
    通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
    
    3.使用特殊域变量(volatile)实现线程同步
    
    volatile关键字为域变量的访问提供了一种免锁机制， 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 因此每次使用该域就要重新计算，而不是使用寄存器中的值 。volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 。
    
    注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。
    
    用final域，有锁保护的域和volatile域可以避免非同步的问题。
    
    4.使用重入锁实现线程同步
    
    在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。
    
    ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
    
    ReenreantLock类的常用方法有：
    
    ReentrantLock() : 创建一个ReentrantLock实例
    
    lock() : 获得锁
    
    unlock() : 释放锁
    
    注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用
    
    5.使用局部变量实现线程同步 
    
    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
    
    ThreadLocal 类的常用方法
    
    ThreadLocal() : 创建一个线程本地变量
    
    get() : 返回此线程局部变量的当前线程副本中的值
    
    initialValue() : 返回此线程局部变量的当前线程的”初始值”
    
    set(T value) : 将此线程局部变量的当前线程副本中的值设置为value

12.锁之间的区别  （synchronized和Lock类的区别吧） -------   https://blog.csdn.net/weixin_40655325/article/details/103003602
     答：首先是存在层次，synchronized是java的关键字，而Lock是一个java的类，synchronized是jvm自动释放的，而lock必须在finally中手动释放。
       synchronized不能在等待过程中响应中断，lock可以。synchronized不能知道是否获取到了锁，lock可以。lock可以提高多个线程并发读写时的访问效率。
       
       
3.Rxjava自定义操作符          ----------     https://blog.csdn.net/u014099894/article/details/51923370
      自定义操作符和Subject。
      
4.ARouter的原理
5.ARouter怎么实现接口调用
6.ARouter怎么实现页面拦截      ---------  https://www.jianshu.com/p/6021f3f61fa6

7.MVP怎么处理内存泄漏           -------   https://www.jianshu.com/p/3ebf5941d309

8.OkHttp怎么实现连接池           ------  https://blog.csdn.net/qinbin2015/article/details/100139375

14.说说binder机制的原理            -----  https://www.cnblogs.com/yocapl/p/12422617.html

12.ViewPager中嵌套ViewPager怎么处理滑动冲突    ----------  https://www.cnblogs.com/zhujiabin/p/7077873.html
     dispatchTouchEvent方法用于事件的分发，Android中所有的事件都必须经过这个方法的分发，
     然后决定是自身消费当前事件还是继续往下分发给子控件处理。返回true表示不继续分发，事件没有被消费。
     返回false则继续往下分发，如果是ViewGroup则分发给onInterceptTouchEvent进行判断是否拦截该事件。
     onTouchEvent方法用于事件的处理，返回true表示消费处理当前事件，返回false则不处理，交给子控件进行继续分发。
     onInterceptTouchEvent是ViewGroup中才有的方法，View中没有，它的作用是负责事件的拦截，返回true的时候表示拦截当前事件，
     不继续往下分发，交给自身的onTouchEvent进行处理。返回false则不拦截，继续往下传。这是ViewGroup特有的方法，
     因为ViewGroup中可能还有子View，而在Android中View中是不能再包含子View的（iOS可以）。

B站三面
1.介绍一下你自已和项目
2.说说为什么考虑离职
3.说说对你们原来公司的印象
4.为什么想来B站？你在B站上常常在看什么？
5.期望薪资是多少？
6.你对搬到上海有什么想法？
腾讯二面
1.为什么考虑换一份工作？
2.在你们公司这几年感觉怎么样？
3.技术选型上，为什么这么考虑？从开发效率，产品性能，产品质量，产品体验等方面考虑
4.你们的产品为什么被砍掉，从哪方面考虑
5.在这几年里，你有做过什么觉得最有价值的工作
6.你还有什么要问我的吗？目前有几个offer，倾向性是怎样的？


9.如果让你来实现一个网络框架，你会考虑什么
10.你做过什么性能优化的工作
11.热修复的原理，资源的热修复的原理,会不会有资源冲突的问题
13.android源码中有哪些设计模式
腾讯
1.介绍一下你们项目的架构
2//.Rxjava是怎么实现线程切换的



     

5.属性动画更新时会回调onDraw吗？  

网易云音乐
1.ViewPager2原理                                   -------------  https://www.jianshu.com/p/f5d18cc2f6ad
2.LifeCycle的原理是怎样的？                        -------------  https://zhuanlan.zhihu.com/p/164371312
3.ViewModel为什么在旋转屏幕后不会丢失状态           -------------  https://blog.csdn.net/vitaviva/article/details/105246639       https://blog.csdn.net/vitaviva/article/details/109256198
4.Drawable与View有什么区别,Drawable有哪些子类     
                        ------------   https://blog.csdn.net/qq_26918031/article/details/56484973
                        ------------   https://zhuanlan.zhihu.com/p/284067956
                        
6.OkHttp网络拦截器，应用拦截器?OKHttp有哪些拦截器，分别起什么作用
      1>：RetryAndFollowUpInterceptor：重试拦截器
      处理重试的一个拦截器，会去处理一些异常，只要不是致命的异常就会重新发起一次请求（把Request给下级），如果是致命的异常就会抛给上一级；
      会去处理一些重定向等等，比如 3xx、307、407，处理的方式就是：从头部的Location中获取一个新的url地址，生成一个新的请求交给下一级（相当于重新发起一次请求）；
      
      2>：BridgeInterceptor：基础的拦截器
      a：做一个简单的处理，设置一些通用的请求头，Cookie、Connection、Content-Type、Content-Length；
      b：做一些返回的处理，如果返回的数据被压缩了，采用 ZipSource，保存Cookie；
      
      3>：CacheInterceptor：缓存拦截器
      在缓存可用的情况下，读取本地的缓存的数据，如果没有直接去服务器读取数据，如果有，首先先判断是否有缓存策略，然后判断是否过期，如果没有过期，直接从缓存中读，如果过期了，你需要添加一些之前的头部信息，比如：If - Modified - Since，这个时候后台服务器有可能给你返回 304，代表你还是可以拿本地缓存，每次读取到新的响应后做一次缓存，这样的话，可以保证下一次从缓冲可以拿到；
      
      4>：ConnectInterceptor：连接的拦截器
      调用findHealthyConnection()：找到一个连接，首先判断有没有健康的，没有就创建（建立socket，握手连接），连接缓存，得到一条结论就是：
      OkHttp是基于原生的 Socket + okio（原生IO的封装）；因为原生的io类太多，所以采用okio；
      HttpCodec：里面封装了 okio 的 Source（输入流）和 Sink（输出流）， 我们通过 HttpCodec就可以操作 Socket的输入输出流，就可以给服务器读数据和写数据；
      
      以后如果有读写数据的需求，可以采用 okio，就可以不用原生的io，但是需要熟悉 okio的 API；
      
      5>：CallServerInterceptor：
      给服务器写数据和读取数据；
      写头部信息，写body表单信息等等；
      
      2. 连接3个核心类（连接复用）
      RealConnection：建立连接的一个对象的封装；
      ConnectionPool：保存了连接；
      StreamAllocation：找一些连接，做一下封装；
      

7.自定义实现一个九宫格如何实现

9.这些年有做一些什么比较难的工作？

10.编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？

11.kotlin lazy使用,lazy viewmodel

12.有没有看一下Google官方的ViewModel demo

13.ViewModel在Activity初始化与在Fragment中初始化，有什么区别？


8.PathClassLoader与DexClassLoader有什么区别
      1.DexClassLoader和PathClassLoader都属于符合双亲委派模型的类加载器（因为它们没有重载loadClass方法）。也就是说，它们在加载一个类之前，回去检查自己以及自己以上的类加载器是否已经加载了这个类。如果已经加载过了，就会直接将之返回，而不会重复加载。
      2.DexClassLoader和PathClassLoader其实都是通过DexFile这个类来实现类加载的。这里需要顺便提一下的是，Dalvik虚拟机识别的是dex文件，而不是class文件。因此，我们供类加载的文件也只能是dex文件，或者包含有dex文件的.apk或.jar文件。
      3.PathClassLoader是通过构造函数new DexFile(path)来产生DexFile对象的；而DexClassLoader则是通过其静态方法loadDex（path, outpath, 0）得到DexFile对象。这两者的区别在于DexClassLoader需要提供一个可写的outpath路径，用来释放.apk包或者.jar包中的dex文件。换个说法来说，就是PathClassLoader不能主动从zip包中释放出dex，因此只支持直接操作dex格式文件，或者已经安装的apk（因为已经安装的apk在cache中存在缓存的dex文件）。而DexClassLoader可以支持.apk、.jar和.dex文件，并且会在指定的outpath路径释放出dex文件。
      4.另外，PathClassLoader在加载类时调用的是DexFile的loadClassBinaryName，而DexClassLoader调用的是loadClass。因此，在使用PathClassLoader时类全名需要用”/”替换”.”

14.kotlin与Java互相调用有什么问题？                                -------------------   https://blog.csdn.net/a568478312/article/details/76258641

15.retrofit怎么做post请求                                         -------------------    https://blog.csdn.net/qq_43586051/article/details/104798970

16.界面优化的一些方法，ConstraintLayout实现三等分,ConstraintLayout动画.    ------   https://www.sohu.com/a/332551298_611601
17.CoordinatorLayout自定义behavior,可以拦截什么？
网易云音乐二面
1.你们的项目中做过什么比较难的工作？
2.视频播放,一个player怎么实现预加载，避免loading
2.webView加载本地图片，如何从安全方面考虑
3.http1.0,http1.1,http1.2有什么区别

5.有用过什么加密算法？AES,RAS什么原理？
     简单来说，两种都是加密算法，不同的是AES是对称加密算法，RSA是非对称算法。
     
     先简单说下概念
     
     对称加密算法：简单来说，使用一个密钥可以加密，也可以解密，所以这样对称被成对称加密。
     
     非对称加密算法：加密之后不可逆，使用配对的公钥，私钥，使用了公钥加密之后，只能私钥才能解密。
     
     RSA最基本的原理：也就是几个数学函数，通俗一点，就是正向axb=y 很好计算y的值，但是通过y的值很难计算出是a、b。比如：666666X7777777=5185179481482正向很好计算结果5185179481482，反向5185179481482很难计算出66666 7777777。这是基本原理。
     
     2.场景再说RSA：
     
     比如A，B两人进行网络业务来往，A通过RSA工具生成A的公钥与私钥，B生成了B的公钥与私钥，公钥无所谓，可以公开。A B为了信息传输安全。
     
     于是A与B互换了公钥，此时A手里是A的私钥，B的公钥；B的手里是B的私钥，A的公钥。
     
     场景1（消息传输）：A，B开始信息传输：A-->B ,表示A传输信息给B，于是A写了一段话（明文），使用了B的公钥加密（此时的信息丢失无所谓，别人拿去也解密不了，因为没有B的私钥），然后传输给B，B使用了B的私钥解密了，看见了明文，使信息得到了安全，反之同理。
     
     场景2（数字签名）：A-->B。收到消息的B要确认是否是A传输给他的消息，A签名之后传可以使用A的私钥加密之后再发给B，B使用A的公钥解密（这里解密之后并不是能看到A的私钥，只是一段摘要，hash值），结果可以验证是否是A，因为A的私钥唯一。
     
     总结：消息传输：公钥加密，私钥解密；数字签名：私钥加密，公钥解密。
     
     3.具体应用：
     
     比如现今天流行的聊天软件：需要配合AES与RSA一起使用。流程如下：
     
     客户端B还有服务端A的公钥P，于是B把相关的账号U，密码W，AES的密钥key使用公钥P加密加密打包发送给服务端A，A接受到消息使用私钥S解密，得到账号密码，验证账户信息是否正确，确认之后，并拿到客户端给的随机AES密钥key（双方约定的一个可key），然后A收到后给B发送消息，则使用key加密传送给B，B拿到密文后，使用key进行解密。后续的操作就使用key进行AES加解密进行消息传输，保证信息安全。大概就这么个流程（当然他们会做的更安全，更新，这里只是简单说下流程）。

6.android跨进程通信了解吗？共享内存用过吗？binder怎么验证pid?binder驱动了解吗？
       https://www.cnblogs.com/andy-songwei/p/10256379.html   android跨进程通信
       
       https://segmentfault.com/a/1190000021126368   https://blog.csdn.net/goodlixueyong/article/details/53151959   https://www.jianshu.com/p/d9bc9c668ba6   共享内存
       
7.SharedParence可以跨进程通信吗？如何改造成可以跨进程通信的.commit和apply的区别.

8.Seriazable与Parceable的区别     https://blog.csdn.net/lynchyo/article/details/38492683


9.Bundle是什么数据结构?利用什么传递数据
10.Jvm的内存结构，Jvm的垃圾回收，方法区有什么东西？
11.h5与native交互，webView.loadUrl与webView.evaluateUrl区别
网易云音乐三面  

2.你们的项目中有什么难点？
3.native如何对h5进行鉴权，让某些页面可以调，某些页面不能调
4.有看过哪些框架的源码吗？
5.viewModel是怎么实现双向数据绑定的？
6.viewModel怎么实现自动处理生命周期？
9.一个wrap_content的ImageView，加载远程图片，传什么参数裁剪比较好?


1.有没有做过什么WebView秒开的一些优化      https://www.jianshu.com/p/f6d581a51e0d
7.图片加载优化有什么经验吗？               https://blog.csdn.net/phj_88/article/details/80949448
10.两个getDrawable取得的对象，有什么区别？      https://blog.csdn.net/u013063185/article/details/80547956
12.jsBridge实现方式            https://segmentfault.com/a/1190000021915545


8.viewpager切换掉帧有什么处理经验？
       1、ViewPager设置预加载
       　　我有4个tag，都不想被销毁，设置预加载个数为3。
       　　ViewPager viewPager;
       　　viewPager.setOffscreenPageLimit(3);
            实测：全部预加载时ViewPager初始化比较慢
       2、PagerAdapter重载destroyItem防止销毁
       @Override
       public void destroyItem(ViewGroup container, int position, Object object) {
            //重载该方法，防止其它视图被销毁，防止加载视图卡顿
            //super.destroyItem(container, position, object);
       }
       

11.补间动画与属性动画的区别，哪个效率更高？
     1、作用对象不同，补间动画只能作用在view上，属性动画可以作用在所有对象上。
     2、属性变化不同，补间动画只是改变显示效果，不会改变view的属性，比如位置、宽高等，而属性动画实际改变对象的属性。
     3、动画效果不同，补间动画只能实现位移、缩放、旋转和透明度四种动画操作，而属性动画还能实现补间动画所有效果及其他更多动画效果。


     
13.平常是怎么了解一些新知识与业界动态的，最近有什么印象深刻的文章
14.平常抓包用什么工具？
15.Mvp与Mvvm有什么区别?
5.算法,删除数组中的重复元素
7.Activity生命周期
跟谁学
1.项目中的Webview与native通信
2.项目中对WebView的功能进行了怎样的增强       -------------------   https://blog.csdn.net/WangRain1/article/details/74517591
3.synchronized跟ReentranLock有什么区别？
4.synchronized与ReentranLock发生异常的场景.    ------------------  https://cloud.tencent.com/developer/article/1509470

6.手写双检查单例模式，各个步骤有什么区别
         
双重校验单例模式(DCL)：
public class Singleton{
    private volatile static Singleton singleton;
    private Singleton(){}
    public static Singleton getSingleton(){
        if(singleton == null){
            //类对象加锁
            synchronized (Singleton.class) {
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }



快手
1.string,equals,==有什么区别
         
“==”操作符的作用
1、用于基本数据类型的比较
2、判断引用是否指向堆内存的同一块地址。

equals的作用：

用于判断两个变量是否是对同一个对象的引用，即堆中的内容是否相同，返回值为布尔类型
String类型比较不同对象内容是否相同，应该用equals，因为==用于比较引用类型和比较基本数据类型时具有不同的功能。
基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。
注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。

== 的作用：
　　基本类型：比较的就是值是否相同
　　引用类型：比较的就是地址值是否相同
equals 的作用:
　　引用类型：默认情况下，比较的是地址值。

注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同
2.AsyncTask内存泄露    ------   https://blog.csdn.net/womengmengyan/article/details/52315564
3.dispatchTouchEvent,onInterceptEvent,onTouchEvent顺序，关系               ----------   https://blog.csdn.net/hty1053240123/article/details/77866302
4.onMeasure,onLayout,onDraw关系
5.算法题，反转数组
6.算法题，链表求和
7.说说你对协程的理解    https://blog.csdn.net/jun5753/article/details/103168268
8.协程怎么取消       https://blog.csdn.net/sunluyao_/article/details/105872823
9.说说MVP与MVVM的区别
快手二面
1.算法题，二叉树的最大深度
2.如果android端和IOS端调一个接口，一个通了一个没通，你会如何解决
3.如果android端和IOS端调一个接口，一个比较慢，一个比较快，有什么思路
4.ARouter的原理是什么？如果不用ARouter，你会怎么去解藕。接口？设计接口有什么需要注意的？
5.h5与native交互做过什么工作？
6.登陆功能，登陆成功然后跳转到一个新Activity，中间涉及什么？从事件传递，网络请求,AMS交互角度分析
7.AMS交互调用生命周期是顺序的吗？
8.binder进程间通信可以调用原进程方法吗？
9.mvp与mvvm有什么区别？
10.token放在本地如何保存？如何加密比较好？
快手三面
1.viewModel的原理，为什么可以在Activity销毁后保存数据
2.mvvm双向数据绑定的原理是怎样的？ViewModel
3.说说你们项目中的难点是怎样的？
4.伪代码实现一个长按事件
5.实现一个下载功能的接口
猿辅导
1.泛型有什么优点？
2.动态代理有什么作用？
3.拉圾回收的GCRoot是什么？
4.Handler机制了解吗？一个线程有几个Looper？为什么？
5.你了解协程吗？协程有什么作用？可以完全取代rxjava吗？
6.你们用的什么消息通信机制
7.你的项目有什么难点？介绍一下？
8.算法题，二叉树最长结点集合
猿辅导2面
1.你们项目中的难点是什么？
2.编译期注解处理的是字节码还是java文件
3.你在项目中有用到什么设计模式吗？
4.ARouter的原理是怎样的？
5.插件化的原理是怎样的？
6.算法题，K个一组反转链表
7.广播与RxBus的区别，全局广播与局部广播区别
猿辅导3面
1.你们项目中有什么难点？
2.@JavaScriptInterface为什么不通过多个方法来实现？
3.为什么不利用同步方法来做jsBridge交互？同步可以做异步，异步不能做同步
4.网络封装怎么实现？
5.算法题，不同面值的几个硬币，怎么求满足条件的最小值
斗鱼
1.说说HashMap的原理
2.说说Java的内存分区
3.讲讲你对垃圾回收机制的了解，老年代有什么算法？
4.说说你对volatile字段有什么用途？
5.说说事件分发机制，怎么写一个不能滑动的ViewPager
6.说说你对类加载机制的了解？DexClassLoader与PathClassLoader的区别
7.说说插件化的原理，资源的插件化id重复如何解决？
8.mvp与mvvm模式的区别是什么？
9.JetPack组件用过哪些？lifeCycle的原理是什么？如果在onStart里面订阅，会回调onCreate吗？
10.单例模式有什么缺点？
11.说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？
12.说说你对Handler机制的了解，同步消息，异步消息等
13.说说你对屏幕刷新机制的了解，双重缓冲，三重缓冲，黄油模型
14.onCreate,onResume,onStart里面，什么地方可以获得宽高
15.为什么view.post可以获得宽高，有看过view.post的源码吗？
16.attachToWindow什么时候调用？
17.DataBinding的原理了解吗？
滴滴一面
1.JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？
2.Handler内存泄漏的GCRoot是什么？
3.动画里面用到了什么设计模式？
4.OkHttp里面用到了什么设计模式？
5.OkHttp连接池是怎么实现的？里面怎么处理SSL？
6.泛型为什么要擦除？kotlin的泛型了解吗？泛型的pecs原则
7.同步屏障
8.性能优化做过什么工作？
9.RecyclerView的缓存结构是怎样的？缓存的是什么？cachedView会执行onBindView吗?
10.RecyclerView嵌套RecyclerView，NestScrollView嵌套ScrollView滑动冲突
11.ViewGroup在Action_Move时onIntercept返回true，事件怎么传递
12.Launcher启动图标，有几个进程？
13.JMM可见性，原子性，有序性，synchronized可以保证什么？
14.源码中有哪里用到了AtomicInt
15.AQS了解吗？
16.Activity内LinearLayout红色wrap_content,包含View绿色wrap_content,求界面颜色
17.ViewModel的使用中有什么坑？
18.有用DSL,anko写过布局吗？
19.HashMap查找的时间复杂度是多少？
20.阿里编程规范不建议使用线程池，为什么？
21.四种线程池原理？
22.了解哪些算法？
23.IdleHandler用过吗？
滴滴二面
1.如何封装一个字符串转数字的工具类
2.如何求当前Activity View的深度
3.多进程怎么实现？如果启动一个多进程APP，会有几个进程运行？
4.反射可以反射final修饰的字段吗？
5.Activity与AppCompactActivity区别，Activity会打包到包里面去吗？
6.如何让两个线程循环交替打印
7.怎么中止一个线程，Thread.Interupt一定有效吗？
8.动画连续调用的原理是什么？
9.做过一些SDK的操作吗？
10.协程可以在Java项目中使用吗？
11.SharedPreference原理？读取xml是在哪个线程?
12.了解APK打包的过程吗？
13.class文件的组成？常量池里面有什么内容？
14.自动装箱发生在什么时候？编译期还是运行期
15.bugly日志收集的原理是什么？
16.启动优化做过什么工作？如果首页就要用到的初始化？
17.DataBinding原理
滴滴3面
1.插件化的原理是什么？有没有什么非运行时插件化的解决方案？
2.ARouter的原理是怎样的？注解处理器是处理java还是字节码
3.java和字节码有什么区别？
4.kotlin空安全的原理是什么？
5.性能优化做过什么工作?有用过什么工具？有没有精确测量的工具？
6.kotlinc与javac编译字节码有什么区别？
7.你在团队中是怎样一个角色？
8.你有没有做什么推进项目的工作
9.说说热修复的原理？
字节跳动
1.你们的项目中有什么难点？
2.你们项目的稳定性如何？有做过什么稳定性优化的工作？
3.WebView性能优化做过什么工作？
4.AIDL in out oneWay代表什么意思？
5.线程池了解多少？拒绝策略有几种,为什么有newSingleThread
6.跨进程通信了解多少？管道了解吗？
7.协程介绍一下，讲一个协程的scope与context，协程的+号代表什么
8.Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？
9.算法斐波那契台阶
10.手写生产者消息者模型
11.IdleHandler应用场景
字节跳动2面
1.自定义圆角图片
2.自定义LinearLayout，怎么测量子View宽高
3.setFactory和setFactory2有什么区别？
4.插件化换肤方案
5.插件化的原理，startActivity hook了哪个方法
6.手势操作ActionCancel后怎么取消
7.怎么优化xml inflate的时间，涉及IO与反射。了解compose吗？
8.算法题：二叉树的每一层最左边节点
9.RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新
11.setOnTouchListener,onClickeListener和onTouchEvent的关系

12.Activity的生命周期和启动模式


字节跳动一面：技术面（电话面）

自我介绍+介绍项目
Activity生命周期，每个回调方法的作用是什么？
事件的分发机制
内存泄漏
遇到过滑动冲突吗？滑动冲突的解决方法
如何进行单元测试，如何保证App稳定 ？
说一说Android中如何查看一个对象的回收情况 ？
Apk的大小如何压缩 ？
如何通过Gradle配置多渠道包？
插件化、组件化、热修复原理分析

Activity 生命周期，A启动B两个状态分别是什么 ，A的onStop一定会执行吗？
surfaceView 和普通view的区别
Bitmap高效加载
线程之间的通信方式handler
内存泄漏
为什么handler可以线程切换
Rxjava map关键字的作用是什么
怎么获取view的宽高，如何确定值是准确的，说了view.post()补充viewTreeObserverOnGlobalLayoutListener
场景题：头条列表有多个不同的card，使用RecyclerView怎么解耦getViewType，获得不同的card

ARouter路由原理
如何管理过多的路由表？
看视频的时候网络请求很慢怎么优化？
说说HTTP3.0有什么改进？
App上线后用户使用时卡顿怎么查看是什么原因？

小米
android事件分发机制，请详细说下整个流程


android view绘制机制和加载过程，请详细说下整个流程


图片的三级缓存中,图片加载到内存中,如果内存快爆了,会发生什么？怎么处理？


A、B、C、D分别是四种Activity的启动模式，那么A->B->C->D->A->B->C->D分别启动，最后的activity栈是怎么样的


Service的生命周期，两种启动方法，有什么区别


Handler、Looper消息队列模型，各部分的作用


Binder原理


描述一次跨进程通讯


Bitmap的处理


手写实现一个网络框架(参考Volley)


插件化框架描述：dynamicLoadApk为例子


热修复原理


Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）


Android部分
View的绘制流程；自定义View如何考虑机型适配；自定义View的事件分发机制；View和ViewGroup分别有哪些事件分发相关的回调方法；自定义View如何提供获取View属性的接口；
Art和Dalvik对比；虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)；JVM内存模型及类加载机制；内存对象的循环引用及避免
内存回收机制与GC算法(各种算法的优缺点以及应用场景)；GC原理时机以及GC对象；内存泄露场景及解决方法；OOM的避免及解决方法
四大组件及生命周期；ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)；Activity的四种启动模式对比；Activity状态保存于恢复
Fragment生命周期；Fragment状态保存
startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用应该如何解耦
AsyncTask原理及不足;IntentService原理
AstncTask+HttpClient与AsyncHttpClient有什么区别
如何保证一个后台服务不被杀死；比较省电的方式是什么
如何通过广播拦截和abort一条短信；广播是否可以请求网络；广播引起anr的时间限制
进程间通信，AIDL
12. Handler机制及底层实现 
    Handler对Activity finish影响。
    在开发的过程中碰到一个棘手的问题，调用Activity.finish函数Acitivity没有执行生命周期的ondestory函数，后面查找半天是因为有一个handler成员，因为它有一个delay消息没有处理，调用Activity.finish，Activity不会马上destory，所以记得在Ativity finish前清理一下handle中的未处理的消息，这样Activity才会顺利的destory
    
    Looper
    通过调用Looper.prepare()创建Looper()对象并绑定到ThreadLocal变量中。 Looper里面包含了messageQueue。 构造器如下：
    
    private Looper()
    {
         mQueue = new MessageQueue();
         mRun = true;
         mThread = Thread.currentThread();
    }
    loop()函数
    
    1）从Looper中取出MessageQueue； 2）循环从MessageQueue中取出Message； 3）从Message中取出Target（Handler对象）； 4）调用tartget的dispatchMessage分发消息。
    
    Handler对象
    重要成员变量：
    
    final MessageQueue mQueue;
    final Looper  mLooper;
    final Callback mCallback;   //用于回调
    Handler对象在发送消息的时候，将MSG的target变量设为自己。这样在Looper对象循环取出msg的时候就可以调用对应handler的dispatchMessage()。此函数分发消息的优先级如下： Message在创建的时候调用Obtain设置了Callback。 Handler在创建的时候传入了Callback。 交给Handler子类的HandleMessage处理（通常的做法）。

13. Binder机制及底层实现 14. ApplicationContext和ActivityContext的区别 15. 一张Bitmap所占内存以及内存占用的计算 16. 对于应用更新这块是如何做的？(灰度，强制更新，分区域更新) 17. 混合开发，RN，weex，H5，小程序(做Android的了解一些前端js等还是很有好处的) 18. 说一款你认为当前比较火的应用并设计(直播APP)

19. 内存泄漏的原因
    1、资源对象没关闭。
    
    如Cursor、File等资源。他们会在finalize中关闭，但这样效率太低。容易造成内存泄露。 SQLiteCursor，当数据量大的时候容易泄露
    
    2、使用Adapter时，没有使用系统缓存的converView。
    
    3、即时调用recycle（）释放不再使用的Bitmap。
    
    适当降低Bitmap的采样率，如：
    
    BitmapFactory.Options options = newBitmapFactory.Options();    
    options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一    
    Bitmap bitmap =BitmapFactory.decodeStream(cr.openInputStream(uri), null, options); preview.setImageBitmap(bitmap);
    4、使用application的context来替代activity相关的context。
    
    尽量避免activity的context在自己的范围外被使用，这样会导致activity无法释放。
    
    5、注册没取消造成内存泄露
    
    如：广播
    
    6、集合中的对象没清理造成的内存泄露我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。
    
    **7、Handler应该申明为静态对象， 并在其内部类中保存一个对外部类的弱引用。

20. 老司机谈APK瘦身套路-图片资源篇------   https://blog.csdn.net/mynameishuangshuai/article/details/51752832

Java部分
集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突及处理算法；ConcurrentHashMap
进程和线程的区别；多线程与线程池
数据一致性如何保证；Synchronized关键字，类锁，方法锁，重入锁
同步的方法；多进程开发以及多进程应用场景
服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达
ThreadLocal原理，实现及如何保证Local属性
String StringBuilder StringBuffer对比
接口与回调；回调的原理；写一个回调demo；
泛型原理，举例说明；解析与分派
抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性
静态属性和静态方法是否可以被继承？是否可以被重写？原因
修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法
13. ArrayList和LinkedList的区别
     ArrayList初试大小为10，大小不够会调用grow扩容：length = length + (length >> 1)
     
     LinkedList中Node first,last。分别指向头尾
     
     ArrayList和LinkedList在性能上各 有优缺点，都有各自所适用的地方，总的说来可以描述如下：
     
     对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。
     在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。
     LinkedList不 支持高效的随机元素访问。
     ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。可以这样说：当操作是在一列 数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中 间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。

14. Iterator和Enumeration的不同
     函数接口不同 Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
     Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。而Iterator是JDK1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。

15. hashmap和hashtable的不同
     1.继承不同。
       public class Hashtable extends Dictionary implements Map
       public class HashMap extends AbstractMap implements Map
       Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。
       Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。
       Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
       Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

16. 接口的注意点
      1.接口中的字段全部默认为 public static类型。
        接口中的方法全部默认为 public类型。
        接口中可以申明内部类，而默认为public static，正因为是static，只是命名空间属于接口，代码逻辑不属于接口。所以不违法接口定义。
        接口本身可以申明为public或者缺省。
        抽象类继承自某接口。如果在抽象类中实现了父类（接口）中的方法，在其子类可以不用实现，否则在子类必须实现。

数据结构与算法
堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)
最快的排序算法是哪个？给阿里2万多名员工按年龄排序应该选择哪个算法？堆和树的区别；写出快排代码；链表逆序代码
求1000以内的水仙花数以及40亿以内的水仙花数
子串包含问题(KMP 算法)写代码实现
万亿级别的两个URL文件A和B，如何求出A和B的差集C,(Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)
蚁群算法与蒙特卡洛算法
写出你所知道的排序算法及时空复杂度，稳定性
百度POI中如何试下查找最近的商家功能(坐标镜像+R树)
其他部分
死锁的四个必要条件
常见编码方式；utf-8编码中的中文占几个字节；int型几个字节
实现一个Json解析器(可以通过正则提高速度)
MVC MVP MVVM; 常见的设计模式；写出观察者模式的代码
TCP的3次握手和四次挥手；TCP与UDP的区别
HTTP协议；HTTP1.0与2.0的区别；HTTP报文结构
HTTP与HTTPS的区别以及如何实现安全性

Activity中的几种启动模式
   activity的几种启动模式是android中常考的知识点，一般会考察有哪几种启动模式，以及每种启动模式在什么场景下使用：
     standard:这个是android默认的Activity启动模式，每启动一个Activity都会被实例化一个Activity，并且新创建的Activity在堆栈中会在栈顶。
     singleTop:如果当前要启动的Activity就是在栈顶的位置，那么此时就会复用该Activity，并且不会重走onCreate方法，会直接它的onNewIntent方法，
               如果不在栈顶，就跟standard一样的。如果当前activity已经在前台显示着，突然来了一条推送消息，此时不想让接收推送的消息的
               activity再次创建，那么此时正好可以用该启动模式，如果之前activity栈中是A-->B-->C如果点击了推动的消息还是A-->B--C，
               不过此时C是不会再次创建的，而是调用C的onNewIntent。而如果现在activity中栈是A-->C-->B，再次打开推送的消息，
               此时跟正常的启动C就没啥区别了，当前栈中就是A-->C-->B-->C了。
     singleTask:该种情况下就比singleTop厉害了，不管在不在栈顶，在Activity的堆栈中永远保持一个。这种启动模式相对于singleTop而言是更加直接，
                比如之前activity栈中有A-->B-->C---D，再次打开了B的时候，在B上面的activity都会从activity栈中被移除。下面的acitivity
                还是不用管，所以此时栈中是A-->B，一般项目中主页面用到该启动模式。
     singleInstance:该种情况就用得比较少了，主要是指在该activity永远只在一个单独的栈中。一旦该模式的activity的实例已经存在于某个栈中，
                任何应用在激活该activity时都会重用该栈中的实例，解决了多个task共享一个activity。其余的基本和上面的singleTask保持一致。
   上面的各种启动模式主要是通过配置清单文件，常见还有在代码中设置flag也能实现上面的功能：
     FLAG_ACTIVITY_CLEAR_TOP：这种启动的话，只能单纯地清空栈上面的acivity，而自己会重新被创建一次，如果当前栈中有A-->B-->C这几种情况，
                              重新打开B之后，此时栈会变成了A-->B，但是此时B会被重新创建，不会走B的onNewIntent方法。这就是单独使用
                              FLAG_ACTIVITY_CLEAR_TOP的用处，能清空栈上面的activity，但是自己会重新创建。
     如果在上面的基础上再加上FLAG_ACTIVITY_SINGLE_TOP此时就不重新创建B了，也就直接走B的onNewIntent。它两者结合着使用就相当于上面的singleTask模式。
     如果只是单独的使用FLAG_ACTIVITY_SINGLE_TOP跟上面的singleTop就没啥区别了。
     FLAG_ACTIVITY_CLEAR_TOP+FLAG_ACTIVITY_SINGLE_TOP=singleTask,此时要打开的activity不会被重建，只是走onNewIntent方法。
     FLAG_ACTIVITY_SINGLE_TOP=singleTop
     FLAG_ACTIVITY_NEW_TASK
   在相同taskAffinity情况下：启动activity是没有任何作用的。
   在不同taskAffinity情况下：
   如果启动不同栈中的activity已经存在了某一个栈中的activity，那么此时是启动不了该activity的，因为栈中已经存在了该activity；
         如果栈中不存在该要启动的activity，那么会启动该acvitity，并且将该activity放入该栈中。
     FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP一起使用，并且要启动的activity的taskAffinity和当前activity的taskAffinity
              不一样才会和singleTask一样的效果，因为要启动的activity和原先的activity不在同一个taskAffinity中，所以能启动该activity，这个地方有点绕，写个简单的公式:
     FLAG_ACTIVITY_NEW_TASK如果启动同一个不同taskAffinity的activity才会有效果。
     FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP如果一起使用要开启的activity和现在的activity处于同一个taskAffinity，那么效果还是跟没加FLAG_ACTIVITY_NEW_TASK是一样的效果。
     FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP启动和现在的activity不是同一个taskAffinity才会和singleTask一样的效果。
     FLAG_ACTIVITY_CLEAR_TASK
   在相同taskAffinity情况下：和FLAG_ACTIVITY_NEW_TASK一起使用，启动activity是没有任何作用的。
   在不同taskAffinity情况下：和FLAG_ACTIVITY_NEW_TASK一起使用，如果要启动的activity不存在栈中，那么启动该acitivity，并且将该activity放入该栈中，
        如果该activity已经存在于该栈中，那么会把当前栈中的activity先移除掉，然后再将该activity放入新的栈中。
     FLAG_ACTIVITY_NEW_TASK+FLAG_ACTIVITY_SINGLE_TOP用在当app正在运行点击push消息进到某个activity中的时候，如果当前处于该activity，此时会触发activity的onNewIntent。
     FLAG_ACTIVITY_NEW_TASK+FLAG_ACTIVITY_CLEAR_TOP用在app没在运行中，启动主页的activity，然后在相应的activity中做相应的activity跳转。
     
     
android消息机制
    消息机制指Handler、Looper、MessageQueue、Message之间如何工作的？
      handler是用来处理消息和接收消息的中间者，handler的创建会伴随着handler中产生looper和MessageQueue，handler依赖于looper，looper依赖于MessageQueue，
      所以在子线程中使用handler抛出异常是因为子线程中没有初始化looper对象，而主线程中looper是在ActivityThread中已经初始化过了，所以能直接在主线程中能拿到Handler。
      Looper是用来轮询消息，说白了就是通过loop方法实现死循环，有消息的时候，通过MessageQueue.next方法取出message，没有消息的时候，线程处于阻塞的状态。
      在有消息的时候获取到消息，将消息交给了handler，handler会根据消息中有没有callback，如果有callback会直接callback，否则通过handleMessage处理。
      MessageQueue是一个单链表结构来存储Message，每次通过next方法取出Message消息后，取完之后将message.next给当前的message，再将message.next=null，
      实际上就是移除当前的message。但是在looper里面每次在next取出message后，放到了message的sPool里面，缓存起来方便使用。
      Message就没什么好说的，主要存储平常经常用的obj和what信息，以及我们不用关心的target和callback等。

这里会问到，一个线程会有几个Looper，几个Handler，以及Looper会存在线程哪里？
    一个线程一个Looper，可以有多个Handler，Looper会存在线程的ThreadLocal对象里，该对象是线程的缓存区
    ThreadLocal:它是和线程一一对应的，从Thread类可以看出来，ThreadLocal是作为Thread变量来使用。ThreadLocal只是ThreadLocalMap的一个包装类，
    实现了get和set方法，而ThreadLocalMap实际是一个由Entry内部类组成的数组，Entry是继承自弱应用，弱引用里面放的就是ThreadLocal当前对象，
    Entry的value存的是当前线程要存储的对象，value作为Entry的成员变量。
    ThreadLocal经常会问到内存泄漏的问题，从上面分析可以发现ThreadLocalMap里面的Entry对象存储的ThreadLocal弱引用，而value直接作为Entry
    的强引用，因此在用到了ThreadLocal的地方，防止内存泄漏，手动调用remove方法。

IntentService
  IntentService是google在原生的Service基础上通过创建子线程的Service。也就是说IntentService是专门为android开发者提供的能在service内部实现
  耗时操作的service。我们可以通过重写onHandleIntent方法实现耗时操作的回调处理，而且IntentService在耗时操作完成后，会主动销毁自己，
  IntentService可以通过多次启动来完成多个任务，而IntentService只会被创建一次，每次启动的时候只会触发onStart方法。内部是实现了Handler
  异步处理耗时操作的过程，一般多用在Service中需要处理耗时操作的功能。
提问：为什么IntentService中能实现耗时操作?
   在onCreate中，通过HandlerThread来开启一条线程，而HandlerThread线程中会跟我们平常用的Handler不太一样，在run方法中创建了looper对象，
   所以HandlerThread能让IntentService在子线程中使用handler达到耗时操作。
HandlerThread
  HandlerThread本身也是Thread，只是在Thread基础上封装上了Handler的载体，并且在run方法中创建了looper对象，这也是为什么在IntentService
  中能在HandlerThread中直接用handler的原因。而我们知道一个线程是可以有多个handler，所以用HandlerThread更加方便我们不用关心Handler的创建，一般用在多线程中直接处理任务。
事件分发
事件分发主要分三块:分发、拦截、消费；
  当我们触摸到屏幕的时候，默认会先走Activity的分发，接着走ViewGroup的分发，然后到ViewGroup的拦截，后面再到View的分发事件，最后会传到View的消费
  事件，如果View不消费，紧接着回传到ViewGroup的消费事件，如果ViewGroup也不消费，最后回到View的消费事件。整个事件分发构成了一个u型结构，下面总结了分发的细节流程：

如果ViewGroup的dispatchTouchEvent返回true或false，touch事件不会往子view中传递，false的时候只会触发action_down，ViewGroup的onTouchEvent事件也不会被触发。只有在返回super.dispatchTouchEvent时候touch事件才会传递到子view。
如果ViewGroup的onInterceptTouchEvent返回false或者super.onInterceptTouchEvent时，touch事件会传递到子view。返回true事件不会向下传递，交给自己的ontouchEvent处理。
如果view的dispatchTouchEvent返回true或false，touch事件不会传给自己的ontouchEvent事件，返回false，只会触发action_down，move和up不会触发；返回true，才会触发move和up。返回super.dispatchTouchEvent，touch事件才会交给自己的onTouchEvent处理。
如果view的ontouchEvent返回false，只会有action_down事件，touch事件交给上一层处理，如果返回true才会消费，事件不会向上传递，如果返回super.ontouchEvent，得看clickable是不是返回true。

这里会问到事件冲突的问题？
事件遵循一个原则，就是看他有没有事件消费。比如一个LinearLayout里面有一个Button，点击LinearLayout会触发到Button吗，这里就看LinearLayout有没有设置点击事件，如果有就不会传递到Button，如果没有就会传递给Button。

android性能优化、内存优化
性能优化:可以从界面、apk瘦身、混淆说起，dex分包处理，插件化动态加载模块，开屏冷启动说起
界面优化：多可以使用include、merge、ViewStub、约束布局来做起，include可以提取公共的布局，merge可以减少布局层次、ViewStub是使用的时候才去创建View，减少空间的占用、约束布局一来可以减少布局的层次、二来可以提高开发的效率，
在自定义view中注意view绘制过程不要做初始化的操作，一般放到view的初始化的方法里面。
apk瘦身：可以用android studio的lint检测工具检测资源文件等
混淆：可以起到文件大小减少的作用，这个在实践中可以尝试，混淆后可以反编译看看apk包的内容
dex分包：主要是apk包的结构发生了变化，如果dex包的方法数超过了最大数，需要进行分包处理
插件化：主要用到了java中动态代理模式和反射的思想，利用android的activity启动流程，通过动态代理模式动态加载我们需要插件化的activity
开屏冷启动：开屏冷启动主要针对MultiDex启动做优化，在5.0之前对dex分包是不做处理的，所以要兼容到低版本的时候需要使用MultiDex.install做兼容。而MutiDex.install将apk中的dex包获取到，然后又压缩成对应的zip文件，
将dex文件通过反射转换成DexFile对象、反射替换数组。所以我们能做的优化可以通过判断如果jvm不支持dex分包处理，通过MutiDex.install做处理，通过监听MutiDex.install开启一个监听MutiDex.install的进程activity。
等到MutiDex.install处理完成后，再来处理正常的逻辑。
内存优化
内存优化通常指的内存溢出，主要涉及到的问题还是该释放的资源，没有及时让GC处理器回收，通常主要表现是动画、上下文对象、EventBus、AsycTask、Handler、单例Bitmap都会影响，通常要做的是释放他们未终止的动作，释放锁定的上下文对象。
在实际项目有mvp架构的时候，需要注意内存泄漏的问题，p层如果长期持有v层的实例，导致v层的对象难以回收，而v层一般是activity或fragment作为抽象，因此需要在p层使用v层的弱应用或是在p层中实现v层的销毁方法，处理销毁的逻辑。
View的绘制
activity界面显示流程:activity启动后，不会立马去显示界面上的view，而是等到onResume的时候才会真正显示view的时机，首先会触发windowManager.addView方法，在该方法中触发代理对象WindowManagerGlobal的addView方法，
代理对象的addView方法中创建了viewRootImpl，将setContentView中创建的decorView通过viewRootImpl的setView方法放到了viewRootImpl中，最终经过viewRootImpl一系列的方法最终调用performTraversals方法。
view的绘制:主要指view的onMeasure、onLayout、onDraw几个方法，其实要了解几个方法，需要追溯到android中本身界面的结构，首先整体是一个PhoneWindow的对象，然后是一个DecorView，DecorView里面包括一个ViewStub的ToolBar，
然后下面是一个FramLayout，也就是我们经常在Activity中setContentView中的content内容。说完了android界面的结构，下面就是说下如何绘制的，绘制首先是触发到DecorView的onMeasure方法，它的测量规则包含了手机屏的宽高，
并且测量模式是MeasureSpec.EXACTLY。所以这里明白了DecorView(FrameLayout)的测量参数是什么意思了，紧接着就是测量它下面的ViewGroup了，其中ViewGroup里面有个measureChild方法去测量孩子，
这里会问到几种父布局的测量模式和子View的测量模式组合:

ViewGroup的测量mode
MeasureSpec.EXACTLY
MeasureSpec.AT_MOST
MeasureSpec.UNSPECIFIED


childDimension>0
size=childDimension;mode=EXACTLY
size= childDimension;mode=EXACTLY
size= childDimension;mode=EXACTLY


childDimension == LayoutParams.MATCH_PARENT
size=Viewgroup的size;mode=EXACTLY
size=Viewgroup的size;mode=AT_MOST
size=Viewgroup的size;mode=UNSPECIFIED


childDimension == LayoutParams.WRAP_CONTENT
size=Viewgroup的size;mode=AT_MOST
size=Viewgroup的size;mode=AT_MOST
size=Viewgroup的size;mode=UNSPECIFIED



测量处理完了之后，紧接着就是View的onLayout，其中onLayout的作用是给View固定好位置，该方法传进来的几个参数是相对于自己的parent的位置，左上角是(0,0)的坐标。最后就是我们的onDraw，该方法是我们需要在画布上画东西的方法，一般包括画背景、画图层等等。
App启动流程

从Linux内核系统到init进程的分裂，以及后面会启动一个叫Zygote的进程开始，而Zygote会分裂出系统的核心服务进程SystemServer，也就是SystemServer里面包括了底层的ActivityManagerService、PackageManagerService、WindowManagerService等，
这些核心服务都是通过Zygote.init启动的，ActivityManagerService就是我们后面通过binder的ipc通信机制来与客户端ActivityThread建立通信的。
当我们点击了应用之后，系统的Launcher应用会通过startActivity的方式启动应用，而Intent的获取会经过如下几部:
(1) ActivityManagerService会通过PackageManager的resolveIntent()收集这个intent对象的指向信息。
(2)指向信息被存储在一个intent对象中。
(3)下面重要的一步是通过grantUriPermissionLocked()方法来验证用户是否有足够的权限去调用该intent对象指向的Activity。
(4)如果有权限, ActivityManagerService会检查并在新的task中启动目标activity.
(5)现在, 是时候检查这个进程的ProcessRecord是否存在了。
所以如果ProcessRecord不是null，ActivityManagerService会创建新的进程来实例化该activity。
ActivityManagerService调用startProcessLocked()方法来创建新的进程, 该方法会通过前面讲到的socket通道传递参数给Zygote进程. Zygote孵化自身, 并调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid。
随后就是我们熟悉的ActivityThread.main方法通过Looper.prepare和Looper.loop方法开启消息循环
紧接着就是创建Application对象的过程，先是创建好ContextImpl对象，然后通过makeApplication方法将app进程与Application建立联系，这里的Application创建交给了Instrumentation的对象，其实后面activity的创建，生命周期的回调都是通过它来触发的。
创建完Application后，紧接着就是我们熟悉的Activity，activity的创建同样交给了Instrumentation对象，上面说过ActivityManagerService会将携带的Intent对象交给了Lanucher应用，Lanucher的startActivity经过一系列的操作，
最终会走Instrumentation的execStartActivity方法，该方法里面会去请求ActivityManagerService服务，最终通过binder通信将信息传给了客户端的ApplicationThread，最终会触发ApplicationThread的scheduleLaunchActivity方法，
该方法将消息发送给了ActivityThread的handler对象，最终交给了Instrumentation对象创建activity。后面也就触发一系列的生命周期方法。

Eventbus原理
EventBus是一款在android开发中使用的发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:
注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅
订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用
发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。
反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。
Rxjava的操作符有哪些，说说他们的作用
just:将同种数据源组合放到被观察者上面
from:将类似数组、集合的数据源放到被观察者上面
map:将一种数据源，转化成另外一种
flatmap:将一种数据源，转化成另外一种数据，并且被转化的数据是乱序排列的
concatmap:将一种数据源，转化成另外一种数据，并且被转化的数据是按照先前的数据源顺序排序的
toList:将数组的形式转化成List集合
subscribeOn:设置Observable的call方法所在的线程，也就是数据来源的线程
observeOn:设置subscribe的call方法所在的线程，也就是数据处理的线程
filter:在被观察者的数据层过滤数据
onErrorResumeNext:出错的时候，可以指定出错的时候的被观察者
retryWhen:出错的时候，重新走一遍被订阅的过程
concat:合并相同类型的被观察者到一个被观察者身上，有点类似集合、数组拼接数据。
zip:处理多种不同结果集的数据发射，一般用得多的地方是多个网络请求组合然后统一处理业务逻辑。
还有很多操作符就自己去看，这些操作符已经够面试用的了。
线程锁 锁方法和类对象啥的有啥区别
线程锁锁方法:是需要等到该线程用完了该方法才能释放同步锁
线程锁锁类对象:是需要等到该线程用完了该类对象才能释放同步锁
区别:是锁方法的区域要小  锁类对象包括了该类的所有属性
AsyncTask原理
AsyncTask主要是对android中java的线程池的封装，该类中默认开启了两个线程池，一个线程池负责任务的排队处理，保证任务被单个处理，另外一个线程池用来专门处理任务，最后任务处理完了，交给Handler发送消息到主线程，
然后Handler处理线程，交给了onPostExecute方法。
内部过程:

AsyncTask初始化阶段创建了WorkerRunnable对象，它是处理doInBackground的Callable对象，接着创建了FutureTask对象，它是将上面WorkerRunnable包装了一层的Runnable和Future对象，实际上线程池要执行的任务就是该WorkerRunnable对象。
在执行任务过程中，通过SerialExecutor对象来排队处理FutureTask，里面通过ArrayDeque来按顺序取出FutureTask，取出后交给了THREAD_POOL_EXECUTOR对象，它是在静态代码块中创建的线程池，所以说THREAD_POOL_EXECUTOR才是正真执行任务的关键地方。
执行完后，剩下的就是主线程的Handler将消息发送到主线程去处理。


问题:


AsyncTask内部会创建一个线程池?
两个线程池，一个线程池负责排队处理任务；另一个线程池用来负责处理FutureTask，也就是将上面WorkerRunnable包装了一层的Runnable对象。


AsyncTask对此执行excute方法会怎样?
直接抛出IllegalStateException(非法状态异常)


说说MVP和MVVM的特点
MVP:主要是分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。没办法，MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。
如果要细说mvp需要注意几点:

p层的逻辑处理单一的功能，不要融合一个模块下的增删改查的整个功能。
由于p层持有了v层的引用，通常在p层使用弱引用来持有view层实例，在p层销毁的时候需要将v层的引用销毁掉。
契合类指的p层和v层的接口类放在一个contract接口类中，契合类方便管理业务层的功能，将单个功能放到一个contract契合类中。比如我们有一个添加书架的功能：

public interface AddBookShelfContract {
    interface View extends BaseContract.BaseView {
        void addBookShelfSuccess(BookShelfItem... bookShelfItem);

        void addBookShelfFail();

        void alreadyBookShelf(BookShelfItem bookShelfItem);
    }

    interface Presenter extends BaseContract.BasePresenter<View> {
        void addBookShelf(String tokenId, BookShelfItem... bookShelfItem);
    }
}

复制代码MVVM:主要是用到了观察者模式，通过数据的改变来通知相应的View改变的过程。M层和上面的MVP中的M层是一样的，都是网络请求+数据缓存来实现该层的，里面的双V，一个指的ViewModel实现的，另外一个AndroidDataBinding实现V层，
ViewModel层获取到M层的数据后，通过观察者模式通知AndroidDataBinding在UI上的改变。缺点的话，只能吐糟下AndroidDataBinding了，在xml中写逻辑的时候，一点提示代码都没有，感觉完全是在写js似的，可读性肯定对于初级的来说还是有点难看懂的。
android中用到的观察者模式有哪些地方
观察者模式是由一个发送者（发送者是笔者自己的称呼，觉较之被观察者贴切得多）和一个观察者构成的、发送者在状态改变时（用户操作、程序主动改变等）主动通知所有观察者作相应的刷新。
android中最经典要说ListView的数据源发生变化了，刷新列表的事例。在setAdapter的时候，生成一个AdapterDataSetObserver，紧接着就是订阅上该观察者，该观察者onChange方法里面有requestLayout方法，该方法是触发UI发生变化的方法。
在BaseAdapter里面可以看到notifyDataSetChanged实际上触发的是DataSetObservable被观察者的notifyChanged方法，notifyChanged会触发AdapterDataSetObserver的onChange方法。所以最终会走listView的requestLayout，最后刷新了UI。
说说google新出的Lifecycle框架
将类的生命周期方法移交到Lifecycle中管理，实现对类的生命周期的监听，从而在Lifecycle中处理生命周期的逻辑代码。这里涉及到几个对象:
LifecycleObserver接口（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。
LifecycleOwner接口（Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。
Lifecycle(生命周期)：和LifecycleOwner不同的是，LifecycleOwner本身持有Lifecycle对象，LifecycleOwner通过其Lifecycle getLifecycle()的接口获取内部Lifecycle对象。
State(当前生命周期所处状态)：几种事件状态。
Event(当前生命周期改变对应的事件)：当Lifecycle发生改变，事件状态的回调event。

okhttp原理
okhttp主要实现了异步、同步的网络操作，创建了不同的call对象，这里的call对象是一个个的runnable对象，由于我们的任务是很多的，因此这里有Dispatcher包装了线程池来处理不同的call，其中该类中创建了三种队列，分别用于存放正在执行的异步任务，
同步队列，以及准备的队列。最后在执行每个任务的时候，采用队列的先进先出原则，处理每一个任务，都是交给了后面的各种拦截器来处理，有请求准备的拦截器、缓存拦截器、网络连接的拦截器，每一个拦截器组成了一个责任链的形式。到最后返回response信息。
OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，
这样就实现了连接池的概念。而OkHttp对Socket的读写操作使用的OkIo库进行了一层封装。

Retrofit原理
retrofit基于okHttp封装成RESTFUL网络请求框架，通过工厂模式配置各种参数，通过动态代理、注解实现网络请求。retrofit利用了工厂模式，将分为生产网络请求执行器(callFactory)、回调方法执行器(callbackExecutor)、
网络请求适配器(CallAdapterFactory)、数据转换器(converterFactory)等几种工厂。
callFactory负责生产okHttp的call，大家都知道okHttp通过生成call对象完成同步和异步的http请求。
callbackExecutor通过判断不同的平台，生成对应平台的数据回调执行器。其中android端的回调执行器是通过handler回调数据。
CallAdapterFactory是数据解析工厂，一般我们配置json的数据解析适配器就行。
converterFactory是数据转换的工厂，一般我们配置Rxjava的数据转换就行。
retrofit通过动态代理模式实现接口类配置的注解、参数解析成HTTP对象，最后通过okHttp实现网络请求。

RxJava 的线程切换原理
RxJava通过subscribeOn指定被观察者发生的线程，observeOn指定观察者发生的线程。其中Schedulers.IO生成的是IoScheduler。通过观察者与被观察者订阅的过程中，首先会触发被观察者的subscribeActual方法，在该方法中，
可以看到最终会走scheduler的schedule方法，所以上面提到的IoScheduler实际是调用了它的schedule方法，最终会在NewThreadWorker里面生成ScheduledExecutorService对象，而ScheduledExecutorService实际是由
ScheduledThreadPoolExecutor创建的一个核心线程，最大线程个数是Integer.MAX_VALUE的线程池。最终会由ScheduledThreadPoolExecutor的submit或schedule方法执行传过来的Runnable对象，而Runnable执行的是被观察者的subscribe方法。
所以解释了被观察者的subscribe方法是在子线程中执行的。


observeOn是观察者发生的线程，AndroidSchedulers.mainThread()实质是HandlerScheduler对象，而在观察者部分，最终观察部分会走Scheduler的scheduleDirect方法，而HandlerScheduler的该方法里面包装了一个ScheduledRunnable对象，
通过主线程的handler.postDelayed处理这个runnable对象。


RecyclerView源码、缓存分析
RecyclerView使用了强大的分工操作，显示、排版由LayoutManager处理，数据显示由adapter处理，item上下左右动态加入绘制由ItemDecoration处理，item的动画由ItemAnimator处理。面试主要分析recyclerView缓存，recyclerView缓存是由
内部类Recycler维护，其中一级缓存有mAttachedScrap，里面放的都是当前屏幕正在显示的viewHolder的缓存，二级缓存是mCachedViews，里面放的都是移出到屏幕外的viewHolder缓存，mRecyclerPool是recyclerView的三级缓存，
一般用在RecyclerView嵌套RecyclerView的时候用得到，比如外层的RecyclerView的item中有RecyclerView，那么里面的RecyclerView通过共用外层的RecyclerView的RecyclerPool来减少里面RecyclerView的ViewHolder创建。
Binder机制
binder机制是android端进程间通信的基石，采用aidl的ipc通信方式，我们可以利用它来定义两个进程相互通信的接口。他是基于Service实现的一种线程间通信机制。它的本质是C/S架构的，需要一个服务器端，一个客户端。
AIDL通信方式里面有四个对象，一个是IInterface，专门用来负责接口的调度，Stub用来负责通信的响应和发送给service端的数据，Proxy负责两个进程通信的包装，算是间接调用Stub的包装类，service是服务端处理数据的关键类。用一张图来表示如下:

Android Jetpack
android jetpack是google专门为开发者快速开发app的一套组件，快速搭建mvvm框架的实现，其中包括Lifecyle、LiveData、ViewModel、Room、DadaBinding、Navigation、Paging、WorkManager等一系列优秀的框架。
Lifecycle：实现和activity、fragment生命周期感知的框架，实现数据层和view层销毁的时候解绑。原理是Lifecycler为每个活动组件添加了一个没有界面的Fragment，利用Fragment周期会根据活动声明周期变化的特性实现的特性，
从而实现生命周期的感知，然后根据注解的Event查找执行相应的方法。
LiveData：提供了一种数据改变的同时，主动去告诉ui，让ui层做出相应的逻辑判断。原理是内部保存了LifecycleOwner和Observer，利用LifecycleOwner感知并处理声明中期的变化，Observer在数据改变时遍历所有观察者并回调方法。
ViewModel：它是我们view层和model层的桥梁，是数据驱动界面的关键地方，也是我们ui层在数据丢失的情况下，viewModel还能继续保持原有的数据，原理是将数据保存到ViewModel中，然后为活动中添加一个HolderFragment，
HolderFragment中保存了ViewStore的实例，ViewStore中使用Map保存了ViewModel，从而在活动重新创建时获取到原来的ViewModel。
Room：是model层本地数据库的框架，通过实体映射到对应的db表结构，将实体映射到db关系型数据库里面。跟greendao差不多，room数据库版本升级数据迁移比greendao迁移要麻烦，个人还是比较喜欢greendao来实现本地数据库。
DadaBinding：是一个可以通过在xml布局文件中实现ui逻辑的框架，并且它的ui层和数据层双向驱动还是挺不错的。
Navigation：是后面新出来的可视化管理fragment的组件，通过在xml中配置fragment之间跳转的关系。

系统打包经过了哪几个流程
打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
编译R.java源码部分以及aidl.java通过javac生成对应的.class文件。
将上面生成的.class文件和第三方jar或者library通过dx工具打包生成dex文件。
生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
zipAlign工具对齐上面签名的apk文件。




